{"pages":[{"title":"404","text":"","path":"404/index-1.html","date":"03-24","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"03-24","excerpt":""},{"title":"about","text":"这是我的第三个博客，前两个分别在博客园和WordPress上，但实在自由空间太少了。还是Github好！来自浙江江山的一只小OIer。求学轨迹：江山实验小学--&gt;江山二中--&gt;杭州学军中学。（吐槽一句，进XJ容易，活下来难QAQ）是一只热爱学(隔)习(膜)的小蒟蒻，已经是OIer龄已有3年，但依然很菜。文化课现在连装B都不行了，菜到对不住我自己つ﹏⊂爱好说广泛也并不广，最爱足球，立场萨米+kop，当然作为一个理性的球迷，当然什么都喜欢，只是偏好而已。 挂一张梅老板的图~~欢迎侃球QQ ：1121147896Email ：w.h.chuan@foxmail.comBlog ：loverchuan.github.io upd 2018-09-08:这是我的第五个blog了。。","path":"about/index.html","date":"03-25","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-24","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-24","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-24","excerpt":""}],"posts":[{"title":"数据结构开坑-codeforces","text":"准备开一个坑填一下。计划：尽可能多做一些通过数量150~400的data structure。这里留一些题解吧。 338E.Optimize!过题人数：391通过情况：2A题目大意：给你一份伪代码，要你优化这份代码。伪代码描述的问题转换一下大概是：给你两个数组a[1..len]和b[1..n]，对于每一个1&lt;=i&lt;=n-len+1，求满足a[1..len]和b[i..i+len-1]能完全匹配的数量。完全匹配是指把2len个数两两匹配（a中的去匹配b中的），所有匹配中在b中选的数一定不小于在a中选的数。题解：考虑a中的每一个数a[i]分别有多少个b中的数可以与其匹配，设个数为c[i]（假设b从小到大排序）。那么显然，要满足c[len]&gt;=1，c[len-1]&gt;=2……这样对于一段区间，从前面的区间继承过来仅仅多了一个数，少了一个数，分别修改影响到的区间就行了。（事实上是个前缀区间）最后怎么样能判定一个区间是否可行？要满足min(c[i]-(len-i+1))&gt;=0。处理方法就是在线段树中对应节点的权值先减掉后面的部分就行了。复杂度$O(nlogn)$。 351D.Jeff and Removing Periods过题人数：390通过情况：4A题目大意：给你一个序列，每个询问询问一段区间，问这个子序列需要多少如下操作次能够使这个子序列长度为0。每次操作：先选择一段相同数字组成的，下标为等差数列的子数列，将其删除，把剩下的数随便重排。题解：注意每个操作以后，可以把剩下数重排。这代表只有除了第一次，其他时候，数列都可以是形如k1 k1 k1... k2 k2 k2... kx kx kx...，这样显然剩下的最多要操作次数为剩下的不同的数的种类。那么我们的任务就是处理第一次。可以发现，答案要么是“数的种类数”，要么是“数的种类数+1”。分别是什么情况呢？当原子数列存在一个数k，使得所有a[i]=k的i组成一个等差数列，答案就是前者，否则是后者。然后这个问题可以怎么做呢？好像网上许多人用了BIT，不过我用了一个叫做“回滚莫队”的东西，还是挺不错的，但是就是码的比较翔，常数也挺大的，没有被卡大概是因为数据不强。复杂度$O(n \\sqrt n)$。 848C.Goodbye Souvenir过题人数：349通过情况：3A题意：给出一个序列和一些操作，每次要么单点修改，要么询问一段区间内，每种权值的数出现的末位置减去首位置的和。权值范围是1~n。题解：考虑把问题转化一下，对于一个区间[l,r]，如果权值k在其中出现位置分别是p1 p2 p3...px，则贡献为px-p1=(px-px-1)+...+(p3-p2)+(p2-p1)。这样我们就做到了“去特殊化”。其实题意还能进一步转化。把每个(pre[a[i]],i)看成一个点其权值为i-pre[a[i]]。这样，问题就变成统计坐标范围在(l,l)到(r,r)中的点的权值之和。这是一个待修改二位数点的问题，现在才发现好像是某数据结构的模板，当然也可以用cdq+bit做，把操作顺序看做一维，剩下的x和y分别看做一维，其中操作一维相当于已经排好序了。但是还有一个问题：怎样处理所有修改过后会新增或移除的(pre[a[i]],i)？可以用set维护，每一个点对给以一个时间戳；对于移除的问题，我们只要加入一些权值取反的点就好了。时间戳永远是关键。复杂度$O(nlog^2 n)$。","path":"2018/09/10/数据结构开坑/","date":"09-10","excerpt":""},{"title":"群论复习","text":"写着主要给自己看的，怕长时间不用忘得彻彻底底。再加上网上写的都太。。跳跃了，群论一下就被他们讲光了，感觉并不是很好。。由于群论里面的杂七杂八的定理太多了，我就能记得起一些写一下吧，请自己见谅233。 群的定义群是一个封闭的代数运算系统。设$G$是一个群，它满足这样几个性质： 1.有且仅有一个唯一的单位元（也叫幺元） $\\epsilon$，$\\forall a \\in G$ 满足${a} \\cdot {\\epsilon} = {\\epsilon} \\cdot {a} = a$；2.$\\forall a \\in G$都有逆元 $a ^ {-1}$，并且满足$a \\cdot a ^ {-1} = a ^ {-1} \\cdot a = \\epsilon$；3.结合律成立，即若$a,b,c \\in G$，则$a \\cdot b \\cdot c = (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$；4.封闭性成立，即若$a,b \\in G$，则$a \\cdot b = c \\in G$。5.消去律成立，即若$a,b,x \\in G$，$a \\cdot x = b \\cdot x$，则$a = b$。（$x$右乘的情况相同） 注意群并不需要满足交换律，也就是说左乘一个元素和右乘一个元素结果可能不同。群其实在日常学习中很常见，只是不知道而已。就比如小学时学的加减法和整数构成了一个整数交换群，其中运算符’$\\cdot$’实际上是’$+$’，单位元是$0$，逆元是相反数。并且很容易证明，它是封闭且结合的。这样假装我们已经踏上了入门的道路。 群的种类谈到分类，群的分类显然也有很多标准。群可以按阶数划分（即群中元素个数），分为无限群和有限群，有限群还可以分为x阶群之类的。群还可以根据其性质划分，比如交换群，就是满足交换律的群。还有一些满足某些特殊性质的群，也有自己的命名。在这里主要想重点写的还是在OI里面会涉及到的置换群及其一些定理。最重要的应该是burnside和Polya。那些群同构同态也会提到吧。还有群的作用。再难的我也不会了。 群的性质定理这里我不知道该怎么写了。。。因为群里面的定理实在是太多了。我们一步步来吧。 定理$1.1$ 广义结合律 我们知道一般的结合律是三元的，即$a \\cdot b \\cdot c = (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$。广义结合律就是扩展到多个元素的情况：$a1 \\cdot a2 \\cdot …… \\cdot ak = (在这个式子中任意加括号后得到的结果)$。说的简单一点，这个可以用归纳秒掉。显然，群满足广义结合律。 定义$1.2$ 方幂 定义群中元素的方幂$a^n = a \\cdot a \\cdot …… \\cdot a（n个a相乘）$ 定义$1.3$ 阶 定义群的阶为$|G|$，即$G$中的元素个数。群的阶不为$0$。阶为$1$的群一定为平凡群（即其中只包含单位元）。并且任意阶数的群都存在（一定可构造）。定义群中元素$a$的阶为满足$a ^ {k} = \\epsilon$的最小正整数$k$。$a$也叫$k$阶元。在无限群中，所有非幺元元素都是无限阶元。 定义$1.4$ 子群 定义子群：若$H \\subseteq G$，且$H$自身也是群，交换群即满足交换律的群，则称$H$是$G$的子群。 定义$1.5$ 交换群 交换群即满足交换律的群，即$\\forall a,b \\in G$都满足$a \\cdot b = b \\cdot a$；交换群也叫阿贝尔群。在交换群中，对于任意元素$a,b$有$(ab) ^ {n} = a ^ n b ^ n$。 定义$1.6$ 循环群 设$G$是循环群，则必有一个生成元$a$，满足$G = \\langle a \\rangle$，表示$G$中所有元素可以表示成$a$的方幂的形式。循环群也可以是无限群。并且，所有循环群都是交换群。在循环群中，对于任意元素$a$有$a ^ m a ^ n = a ^ {m + n}，(a ^ m) ^ n = a ^ {mn}$。且若这个循环群阶无限，则$\\forall m \\neq n，a ^ m \\neq a ^ n$。否则阶有限，则$\\forall a ^ m = a ^ n，m - n \\equiv 0 (mod |G|)$ 定理$1.7$ 若$G$是$n$阶循环群，设$a$为其生成元，则若$a ^ m$是$n$阶元，当且仅当$n \\bot m$。证明：可通过剩余系证明。 定理$1.8$ 若群$G$是循环群，则$G$的子群也是循环群。证明：设$G = \\langle a \\rangle$的某一个子群为$H$。若$H = \\{\\epsilon\\}$，则显然命题成立。若$|H| &gt; 1$，$a ^ {k} \\in H$且$m$是最小正整数。显然，所有形如$a ^ {km}（km &lt; n）$的元素都在这个子群中。由于这是一个循环群，只有一个“基元素”$a$，所以如果我们确定如果对于所有$k$，都有$m | km（mod n）$，就表示结论成立，且$H = \\langle a ^ {m} \\rangle$。我们采用反证法。如果存在$l \\equiv km (mod n)$且$m \\nmid l$，则显然，$a ^ {l mod m}$也在这个子群中，且方幂小于$m$，这和假设矛盾。因此结论是成立的。 下面进行置换群中的讨论。 置换群简介置换 置换在表面上像是一个排列。没错，这是最原始最基本的置换，又排列表示。举个例子，有一个置换$\\alpha$。 \\alpha = \\left(\\begin{array}{} 1 & 2 & ... & i & ... & n\\\\ \\alpha(1) & \\alpha(2) & ... & \\alpha(i) & ... & \\alpha(n) \\end{array}\\right)其实，我们也可以从函数的角度来看置换，即定义映射$\\alpha:X \\rightarrow X$，其中$X = \\{1,2,…,n\\}$。在这里，置换也是一个双射（那就是为什么它也是一个排列）。 置换+群？将置换引入群内，就有了置换群。那群中的元素又是什么？置换。这看上去很疯狂，但是慢慢的，你就会觉得它和其它群也没有什么区别。其实坦白说，置换群更为常用和常见一些。 定义$2.1$ 对称群 称集合$X$的全体置换的族为$X$上的对称群，记为$S_X$。当$X = \\{1, 2, …,n\\}$时，常用$S_n$表示n个字母上的对称群。 摘自《高等近世代数》。这里其实……感觉就是定义一些东西吧。这个“字母”应该是翻译的问题，本义就是$X$中的元素（或者称为位置）。 定义$2.2$ 轮换、对换 设$i_1, i_2, …, i_r$是$\\{1,2,…,n\\}$中不同的整数。如果$\\alpha \\in S_n$ 固定其他位置，且\\alpha(i_1) = i_2, \\alpha(i_2) = i_3, ..., \\alpha(i_{r-1}) = i_r, \\alpha(i_r) = i_1则称$\\alpha$是一个$r$-轮换，也叫做$\\alpha$长度为$r$的轮换，记为\\alpha = (i_1 i_2...i_r)事实上，这个记号根据其定义其实有r种不同的标记方法，即： (i_1 i_2...i_r) = (i_2 i_3...i_1) = ... = (i_r i_1...i_{r-1})其中一个长度为$2$的轮换也叫作对换。$1$轮换可以看成“恒等函数”，它固定每个位置。 定义$2.3$ 置换相交 称两个置换是$\\alpha, \\beta$是相交的，当且仅当$\\exists i$同时被一个置换或固定。即：如果$\\alpha(i) = i$且$\\beta(i) = i$或$\\alpha(i) \\neq i$且$\\beta(i) \\neq i$，则$\\alpha, \\beta$是相交的。否则是不相交的。 例$2.3$ 置换复合 我们说置换就像函数一样。那么既然有复合函数，也应当有复合置换。举个例子：设在对称群$S_9$中$\\beta = (1 6), \\gamma = (2 4), \\delta = (3 7 8 9)$，则$\\beta \\gamma \\delta(1) = 6$。其实相当于函数计算的过程。事实上，将$\\beta \\gamma \\delta$复合起来，可以得到一个全新的置换$\\alpha$，一个置换能代替这三个的作用。则有$\\alpha(i) = \\beta \\gamma \\delta(i)$ （对于所有$i$）。那如何计算$\\alpha$？注意到$\\beta，\\gamma，\\delta$两两不交，那么我们就可以直接合并：$\\alpha = (1 6)(2 4)(3 7 8 9)(5)$。最后一个$5$是因为它始终保持不变，是个$1$-轮换。那如果有相交呢？比如在对称群$S_5$中，$\\beta = (1 2), \\gamma = (1 3 4 2 5), \\delta = (2 5 1 3)$。显然$\\alpha = (1 2)(1 3 4 2 5)(2 5 1 3)$，但还需要进一步的化简。我们回忆在刚开始介绍置换群时把一个置换写成两行的形式。这提醒了我们，只要把每个位置$i$上最终是什么算出来就好了。我们从置换的右端开始计算。（这其实是一个很棒的习惯，想想计算函数的时候？）$\\alpha: 1 ↦ 3 ↦ 4 ↦ 4$$\\alpha: 2 ↦ 5 ↦ 1 ↦ 2$$\\alpha: 3 ↦ 2 ↦ 5 ↦ 5$$\\alpha: 4 ↦ 4 ↦ 2 ↦ 1$$\\alpha: 5 ↦ 1 ↦ 3 ↦ 3$这样，我们把这些记号写成两层，就变成了： \\alpha = \\left(\\begin{array}{} 1 & 2 & 3 & 4 & 5\\\\ 4 & 2 & 5 & 1 & 3 \\end{array}\\right)然后怎么做？我们下一步是要把原置换拆成几个不相交的轮换的乘积。观察一下，发现$\\alpha(1) = 4, \\alpha(4) = 1$。好像经过若干次（最多$5$次置换后）会回归原位置！并且对于每个轮换都是这样。然后我们就可以分解了：$\\alpha = (1 4)(2)(3 5)$。这个例子下面的定理做了或多或少一些铺垫。 系$2.4$ 不相交置换$\\alpha，\\beta \\in S_n$可交换。可以考虑每个位置最终状态。 定义$2.5$ 完全轮换分解 置换$\\alpha$的完全轮换分解是指$\\alpha$分解为不相交轮换的轮换分解。 定理$2.6$ 轮换分解定理 设$\\alpha = \\beta _1 \\beta _2 … \\beta _t $是不相交轮换的完全轮换分解，如果不计各轮换出现的次序，该分解是唯一的。对唯一性的证明，一般可以采取反证法。 定义$2.7$ 轮换结构 称两个置换$\\alpha，\\beta \\in S_n$有相同的轮换结构，如果在它们的完全轮换分解中，对于每个$r$，它们所含的$r$-轮换个数相等。 例$2.8$这个例子为下面一般性的结果做个铺垫。 设$\\gamma = (1 3)(2 4 7)(5)(6)$，$\\alpha = (2 5 6)(1 4 3)$，则$\\alpha \\gamma \\alpha ^ {-1} = (4 1)(5 3 7)(6)(2) = (\\alpha1 \\alpha3)(\\alpha2 \\alpha4 \\alpha7)(\\alpha5)(\\alpha6)$。 引理$2.9$ 如果$\\alpha ，\\gamma \\in S_n$，则$\\alpha \\gamma \\alpha ^ {-1}$与$\\gamma$有相同的轮换结构。详细说，如果$\\gamma$的完全轮换分解为$\\gamma = \\beta _1 \\beta _2 …(i_1i_2…)… \\beta _t$，则$\\alpha \\gamma \\alpha ^ {-1}$可以这样得到：在$\\gamma$的轮换中把$\\alpha$作用到各个记号上（设其为$\\sigma$。证明：主要思路就是对于$\\sigma$固定的$i$，证明$\\alpha \\gamma \\alpha ^ {-1}$也固定这个$i$；对于$\\sigma$移动的$i$，证明$\\alpha \\gamma \\alpha ^ {-1}$的移动是与其等价的。 定理$2.10$ $S_n$中置换$\\gamma$和$\\sigma$具有相同的轮换结构当且仅当存在$\\alpha \\in S_n$使得$\\sigma = \\alpha \\gamma \\alpha ^ {-1}$。充分性已经在引理$2.9$中证明。下证必要性。由于已知$\\gamma$和$\\sigma$具有相同的轮换结构，那么对于$\\gamma$的轮换分解中的每个轮换，都可以找到任意一个$\\sigma$中的一个等长轮换。我们把它们一一对应起来：$\\gamma = \\delta_1 \\delta_2 … (i_1i_2…) …\\delta_t$$\\sigma = \\eta_1 \\eta_2 … (j_1j_2…) …\\eta_t$定义$\\alpha$为“下移”函数，即形如$\\alpha(i_1) = j_1$，$\\alpha(i_2) = j_2$的样子。显然，$\\alpha$已经满足$\\sigma = \\alpha \\gamma \\alpha ^ {-1}$，只需要知道$\\alpha$是不是一个置换就好了。而由于$\\gamma$和$\\sigma$都是置换，可知$\\alpha$也是一个置换。 系$2.11$ 如果$n \\geq 2$，则每个$\\alpha \\in S_n$都是对换的乘积。例如$\\beta = (1 2 … r) = (1 r)(1 r-1)…(1 3)(1 2)$。 定义$2.12$ 置换的奇偶性 称置换$\\alpha \\in S_n$是偶置换，如果它能分解成偶数个对换的乘积否则它是奇置换。定义符号$sgn(\\alpha) = (-1) ^ {n-t}$，其中$t$是$\\alpha$完全轮换分解中轮换的个数。显然$sgn$函数是合理定义的。 但是有一个问题：置换的奇偶性是唯一的吗？这个问题我自己好像也不会证明。书上好像也没有写。所有下面一部分可能没有证明。 定理$2.13$ $sgn$函数性质 如果$\\alpha，\\beta \\in S_n$，则$sgn(\\alpha \\beta) = sgn(\\alpha)sgn(\\beta)$。若$sgn(\\alpha) = -1$，则$\\alpha$是奇置换，若$sgn(\\alpha) = 1$，则$\\alpha$是偶置换。置换$\\alpha$是奇置换当且仅当它是奇数个对换的乘积。还有一个挺显然的结论：$奇 \\cdot 奇 = 偶$$奇 \\cdot 偶 = 奇$$偶 \\cdot 奇 = 奇$$偶 \\cdot 偶 = 偶$可以类比一下某些运算符的性质。 这里的证明都先跳吧。 置换群基础部分就到这里为止了。下面跳过一些非必需部分，进入一些重点的讨论。 陪集陪集算是群论里面非常重要的一部分了。 定义$3.1$ 陪集 如果群$H$是$G$的子群，且$a \\in G$，则$G$的子集$aH$叫做陪集，其中 $aH = \\{ ah : h \\in H \\}$。这里定义的其实是左陪集，还有对应的右陪集。一般左右陪集是不同的。 引理$3.2$ 设$H$是群$G$的子群，并设$a，b \\in G$。1.$aH = bH$当且仅当$b ^ {-1}a \\in H$。特别地，$aH = H$当且仅当$a \\in H$。2.如果$aH \\cap bH \\neq \\emptyset$，则$aH = bH$。3.对于一切$a \\in G$，$|aH| = |H|$。证明：1.“特别地”后面的那句话非常好证，只要反证就行了。然后证明一般情况时相当于要证明$b ^ {-1}aH = H$当且仅当$b ^ {-1}a \\in H$就好了。2.如果$aH \\cap bH \\neq \\emptyset$，则$b ^ {-1}aH \\cap H \\neq \\emptyset$，由于$H$是群，所以$b ^ {-1}a \\in H$，再由1得$aH = bH$。3.$h↦ ah$是$H \\rightarrow aH$的双射。双设满足原象的元素个数等于象的元素个数。 事实上，根据这些引理，我们就可以定义在群$G$上如下的关系：$a \\equiv b$如果$b ^ {-1}a \\in H$。可以证明这是一个等价关系，所有陪集构成了等价类。 定理$3.3$ 拉格朗日定理 如果群$H$是有限群$G$的子群，则$|H|$是$|G|$的因数。证明：设$\\{a_1H，a_2H，…，a_tH\\}$是$G$中一切不同陪集的族，则 G = a_1H \\cup a_2H \\cup...\\cup a_tH其中“$\\cup$”在这里是不相交并，则因此有 |G| = |a_1H| + |a_2H| + ... + |a_tH|由引理$3.2$可得$|G| = t|H|$。 定义$3.4$ $G$中子群$H$的指数是指$G$中$H$的左陪集个数（事实上也是右陪集个数），记为$[G:H]$。根据拉格朗日定理，我们有公式： [G:H] = \\frac {|G|}{|H|} 这是现阶段最重要，或说是意义最大的一个定理，只是现在我们还不知道它有什么用。 系$3.5$ 设$G$是有限群，$a \\in G$，则$a$的阶是$|G|$的因数，且$a ^ {|G|} = 1$。证明：有一个结论就$a$的阶是$| \\langle a \\rangle|$（其中$\\langle a \\rangle$是$G$的子群）根据拉格朗日定理可得命题前半句成立。后半句根据元素阶的定义显然也成立。 定理$3.6$ 如果$p$是素数，则每个阶为$p$的群都是循环群。证明：如果$a \\in G$且$a \\neq \\epsilon$，则$a$的阶$d&gt;1$且$d$是$p$的因数。因为$p$是素数，所以$d = p$，则$G =\\langle a \\rangle $，是循环群。 系$3.7$ 设$G$是$4$阶群，则$G$不是循环群就是交换群。若$G$不是循环群，易得群中不含$3$,$4$阶及以上元素。则有$1$个单位元和$3$个$2$阶元素。设$G = \\{\\epsilon , a, b, c\\}$。因为$a \\neq b$且$a，b$都是二阶元素，所以$c = a \\cdot b \\neq \\epsilon，a，b$。同理可得$b \\cdot a$的结果也是$c$。同样可以验证其他元素。这种$4$阶交换群叫做V群。因此$4$阶群$G$不是肯定是交换群。 这个例子并不是说有多大的作用，只是在引导我们确定群的性质时给出了一种思路。 接下来应该是群同态，同构的部分。感觉这部分写起来会非常的累，并且感觉自己对这块内容不是特别熟悉。 同态及同构同构这一方面的理论会令人感觉比较不熟悉。 定义$4.1$ 同态、同构 然后$(G, \\cdot)，(H, \\cdot)$是两个群，其中乘号是这个群内的运算。则函数$f: G\\rightarrow H$称为同态，如果$\\forall x,y \\in G， f(x \\cdot y)=f(x) \\circ f(y)$。如果$f$还是一个双射，则称$f$为同构。两个群称为同构的，如果它们之间存在关系$f: G\\rightarrow H$，记为$G \\cong H$。 下面是群同构满足的条件。引理$4.2$ 设$f: G\\rightarrow H$是群同态。1.$f(\\epsilon) = \\epsilon$2.$f(x ^ {-1}) = f(x) ^ {-1}$3.$\\forall n \\in \\mathbb {Z}， f(x ^ n) = f(x) ^ n$ 证明：1.$1 \\cdot 1 = 1$蕴含$f(1) = f(1)f(1)$。2.$x \\cdot x ^ {-1} = 1$蕴含$f(1) = f(x)f(x ^ {-1})$。3.运用归纳法以及上一点来证明。 定义$4.3$ 不变量 群$G$的一个性质为任意一个同构于它的群所共有称为$G$的一个不变量。 例如阶$|G|$就是一个$G$的不变量，因为所有同构的群拥有相同元素（即相同的阶）。交换群的满足交换律的性质也是一个不变量。再如相同阶元素个数相同也是一个不变量。由此可以初步判断一些群是否同构。 定义$4.4$ 核、象 设$f: G\\rightarrow H$是同态，定义：$f的核 = \\{x \\in G : f(x) = 1 \\}$$f的象 = \\{h \\in H : \\exists x \\in G， h = f(x) \\}$通常记$f$的核为ker$f$，$f$的象为im$f$。 引理$4.5$ 设$f: G\\rightarrow H$是同态。(1).ker$f$是$G$的子群，im$f$是$H$的子群。(2).如果$x \\in $ker$f$，$a \\in G$，则$axa^{-1} \\in$ker$f$。(3).$f$是单射当且仅当ker$f$={1}。 证明：(1).根据定义显然成立。(2).$f(axa^{-1}) = f(a)f(x)f(a^{-1}) = f(a)1f(a)^{-1} = 1$。(3).$f(a)=f(b)当且仅当f(b^{-1}a)=1$。 定义$4.6$ 正规子群 群$G$的子群$K$称为正规子群，如果$k \\in K$和$g \\in G$蕴含$gkg^{-1} \\in K$。如果$K$是$G$的正规子群，记为$K \\triangleleft G$。如果群$G$是交换群，显然$G$的每个子群都是正规子群。但反过来不一定成立，比如四元数群。 定义$4.7$ 共轭 如果$G$是群，$a \\in G$，则形如$gag^{-1}$的$G$中任一元素称为$a$的一个共轭元素，其中$g \\in G$。定义共轭$\\gamma_g: G \\rightarrow G$为对一切$a \\in G$，$\\gamma_g(a) = gag^{-1}$，其中$g \\in G$。 显然，子群$K \\leq G$是正规子群当且仅当$K$中包含$G$的一切元素的共轭元素。共轭$\\gamma_g: G \\rightarrow G$是同构，且共轭元素具有相同的阶。 例$4.8$ 定理2.10证明了$S_n$中两个置换共轭当且仅当它们拥有相同的轮换结构。 定义$4.9$ 群$G$的中心，记为$Z(G)$，定义为$Z(G)=\\{z \\in G:\\forall g \\in G, zg = gz\\}$。 可知$Z(G)$是群$G$的子群，还是正规子群。且群$G$是阿贝尔群当且仅当$Z(G) = G$，这也是显然可知的。如果$Z(G) = \\{1\\}$，则称群$G$为无中心群。比如对于$n \\geq 3$，对称群$Sn$都是无中心群。 定义$4.10$ 自同构、内自同构 如果$G$是群，则同构$f: G \\rightarrow G$称为$G$的自同构。例如每个共轭$\\gamma_g$就是自同构（进一步称为内自同构）。$G$的一切自同构的集合$Aut(G)$在复合下也是一个群，而一切共轭的集合$Inn(G) = \\{\\gamma_g : g \\in G\\}$是$Aut(G)$的子群。","path":"2018/08/09/群论复习/","date":"08-09","excerpt":""},{"title":"2018hdu多校第4场补题","text":"自己学校出的毒瘤场。。吃枣药丸hdu中的题号是6332 ～ 6343。 K. Expression in Memories题意： 判断一个简化版的算术表达式是否合法。 题解： 注意细节即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int n; char s[505];int main () &#123; int T; cin&gt;&gt;T; for ( ; T; --T) &#123; scanf(\"%s\",s+1),n=strlen(s+1),s[0]='+'; if (s[1]=='?') s[1]='9'; bool ok=1; for (int i=2; i&lt;=n; ++i) &#123; if (s[i]=='+'||s[i]=='*') &#123; if (s[i-1]=='+'||s[i-1]=='*') &#123;ok=0; break;&#125; &#125; else if (s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') &#123; if (s[i-1]=='0'&amp;&amp;(s[i-2]=='+'||s[i-2]=='*')) &#123;ok=0; break;&#125; &#125; else if (s[i]=='?') &#123; if (s[i-1]=='+'||s[i-1]=='*') s[i]='9'; else if (s[i-1]=='0') &#123; if (s[i-2]=='+'||s[i-2]=='*') s[i]='+'; else s[i]='9'; &#125; else if (s[i-1]&gt;='1'&amp;&amp;s[i-1]&lt;='9') s[i]='9'; &#125; &#125; if (s[n]=='+'||s[n]=='*'||s[1]=='+'||s[1]=='*') ok=0; if (n&gt;=2) &#123; if (s[1]=='0'&amp;&amp;s[2]&gt;='0'&amp;&amp;s[2]&lt;='9') ok=0; &#125; if (!ok) puts(\"IMPOSSIBLE\"); else &#123; for (int i=1; i&lt;=n; ++i) printf(\"%c\",s[i]); puts(\"\"); &#125; &#125; return 0;&#125; L. Graph Theory Homework题意： 给你一张每个点有点权的完全图。从点$i$走到点$j$ $（i≠j）$的代价为 $\\lfloor \\sqrt {|wi-wj|} \\rfloor$球从$1$走到$n$的最小代价。 题解： 一个不等式： $\\lfloor \\sqrt {a} \\rfloor + \\lfloor \\sqrt {b} \\rfloor \\geq \\lfloor \\sqrt {a+b} \\rfloor$则，从$1$不经过任何点直接到$n$是最优的。 代码：1234567891011121314#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N],w2[N];int main () &#123; int T,n; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\",&amp;w[i]); printf(\"%d\\n\",(int)sqrt(abs(w[n]-w[1]))); &#125; return 0;&#125; D. Nothing is Impossible题意： 没有题意，至今还不知道最终的题意。 题解： 没有题解，只需要大胆猜想，无需证明，取最小的几个$bi$使得$\\prod {(bi + 1)} \\leq m$就行了。能取到的最多个数就是答案。 代码：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int b[105];int main()&#123; int T, n, m, x; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = n; long long now = 1; for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;x, &amp;b[i]); sort(b + 1, b + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; if (now * (b[i] + 1) &gt; m) &#123;ans = i - 1; break;&#125; now *= (b[i] + 1); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; E. Matrix from Arrays题意： 给你一个$L$个元素的数组$A$，根据题意构造一个无限矩阵，并进行$q$次询问，询问一个有限矩阵内的元素和。 题解： 容易发现，构造出来的无限矩阵是一个循环矩阵。当$L$是奇数时，矩阵每${L} \\cdot {L}$个元素循环；当$L$是偶数时，矩阵每${2L} * {2L}$个元素循环。这样我们就可以预处理处一个很小（边长$80$以内)的矩阵，然后做一下前缀和。最后询问的时候留给我们解决的也不多了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int L, Q; ll A[20], M[90][90], s1[90], s2[90], sum;ll calc (int x, int y, ll ret = 0) &#123; ll k1 = (x + 1) / (2 * L), k2 = (y + 1) / (2 * L); ll o1 = (x + 1) % (2 * L), o2 = (y + 1) % (2 * L); ret += sum * k1 * k2; if (o1) ret += s1[o1 - 1] * k2; if (o2) ret += s2[o2 - 1] * k1; for (int i = 0; i &lt; o1; ++i) &#123; for (int j = 0; j &lt; o2; ++j) ret += M[i][j]; &#125; return ret;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; L; for (int i = 0; i &lt; L; ++i) cin &gt;&gt; A[i]; int cursor = 0; for (int i = 0; i &lt; 4 * L; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; M[j][i - j] = A[cursor]; cursor = (cursor + 1) % L; &#125; &#125; sum = 0; for (int i = 0; i &lt; 2 * L; ++i) &#123; for (int j = 0; j &lt; 2 * L; ++j) sum += M[i][j]; &#125; memset(s1, 0, sizeof s1); memset(s2, 0, sizeof s2); for (int i = 0; i &lt; 2 * L; ++i) &#123; for (int j = 0; j &lt; 2 * L; ++j) s1[i] += M[i][j]; if (i) s1[i] += s1[i - 1]; &#125; for (int j = 0; j &lt; 2 * L; ++j) &#123; for (int i = 0; i &lt; 2 * L; ++i) s2[j] += M[i][j]; if (j) s2[j] += s2[j - 1]; &#125; cin &gt;&gt; Q; for ( ; Q; --Q) &#123; int l, u, r, d; scanf(\"%d%d%d%d\", &amp;l, &amp;u, &amp;r, &amp;d); printf(\"%lld\\n\", calc(r, d) - calc(r, u - 1) - calc(l - 1, d) + calc(l - 1, u - 1)); &#125; &#125; return 0;&#125; J. Let Sudoku Rotate题意： 有一个合法的$4$阶数独，某人随机把几个“宫”分别逆时针翻转了几次，先给出现在的数独，问那个人总共最少转了几次。 题解： 如果你够大胆，就去爆搜吧；如果你不够大胆，就去$dlx$吧！反正都能过，可能是因为合法情况太少的缘故 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 17, M = 5;int n, m, ans, a[N][N], tmp[M][M]; char s[N];int R[N][N], C[N][N];void rotating_lalala (int r, int c) &#123; int _u = r * m, _d = _u + m, _l = c * m, _r = _l + m; for (int i = _u; i &lt; _d; ++i) for (int j = _l; j &lt; _r; ++j) tmp[j - _l][m - (i - _u) - 1] = a[i][j]; for (int i = _u; i &lt; _d; ++i) for (int j = _l; j &lt; _r; ++j) a[i][j] = tmp[i - _u][j - _l];&#125;bool exam (int r, int c) &#123; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int x = r * m + i, y = c * m + j; if (R[x][a[x][y]]) return 0; if (C[y][a[x][y]]) return 0; &#125; &#125; return 1;&#125;void fig (int r, int c, int d) &#123; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int x = r * m + i, y = c * m + j; R[x][a[x][y]] += d, C[y][a[x][y]] += d; &#125; &#125;&#125;void dfs (int r, int c, int cnt) &#123; if (cnt &gt;= ans) return; if (c == m) c = 0, ++r; if (r == m &amp;&amp; c == 0) &#123;ans = cnt; return;&#125; if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 0), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 1), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 2), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 3), fig(r, c, -1); rotating_lalala(r, c);&#125;int main () &#123; int T; cin &gt;&gt; T; m = 4, n = 16; for ( ; T; --T) &#123; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%s\", s); for (int j = 0; j &lt; n; ++j) &#123; if (s[j] &gt;= '0' &amp;&amp; s[j] &lt;= '9') a[i][j] = s[j] - '0'; else a[i][j] = s[j] - 'A' + 10; &#125; &#125; ans = 64; memset(R, 0, sizeof R), memset(C, 0, sizeof C); dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B. Harvest of Apples题意： 求$\\sum_{i=0}^{m} {C_{n}^{i}}$，$n，m$都是$1e5$范围，还有$1e5$组询问。 题解： 早就见识过这个东西的厉害。但一起一直不知道怎么做。也不知道有没有柿子。然后就去$OEIS$了一发，结果什么都没有。。OEIS大法失灵了 还是我等蒟蒻不会用。考场上想过离线，也想过$n$和$n-1$，$m$和$m-1$的关系，但是就没有想到莫队。首先，设$S(n, m) = \\sum_{i=0}^{m} {C_{n}^{i}}$，利用杨辉三角那个公式，我们有柿子：$S(n, m) = S(n, m - 1) + C_{n}^{m}$$S(n, m) = 2 * S(n - 1, m) - C_{n-1}^{m}$这样我们发现，等式两边给出的两对关系，让我们真的可以愉快地搞莫队了。而且很好码，双倍的快乐嘻嘻嘻转移复杂度是$O(1)$的。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 100005, mo = 1e9 + 7, inv2 = 500000004;int n, siz, l, r; ll ret, fac[N], inv[N], ans[N];struct que &#123; int l, r, i; bool operator &lt; (const que &amp;o) const &#123; return (r - 1) / siz == (o.r - 1) / siz ? l &lt; o.l : r &lt; o.r; &#125;&#125; a[N];ll ksm (ll b, ll p) &#123; if (p &lt; 2) return p ? b : 1; ll t = ksm(b, p &gt;&gt; 1); t = t * t % mo; return p &amp; 1 ? t * b % mo : t;&#125;ll C (int n, int r) &#123; if (r &lt; 0 || n &lt; r) return 0; return fac[n] * inv[r] % mo * inv[n - r] % mo;&#125;void ppw () &#123; fac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = fac[i - 1] * i % mo; inv[N - 1] = ksm(fac[N - 1], mo - 2); for (int i = N - 2; ~i; --i) inv[i] = inv[i + 1] * (i + 1) % mo;&#125;void add (int x, bool o) &#123; if (!o) ret -= C(r, l + 1); else ret = ret * 2 - C(r - 1, l); ret = (ret + mo) % mo;&#125;void rem (int x, bool o) &#123; if (!o) ret += C(r, l + 1); else ret = (ret + C(r - 1, l)) * inv2; ret = ret % mo;&#125;int main () &#123; cin &gt;&gt; n, siz = sqrt(n + 0.5), ppw(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].r, &amp;a[i].l); a[i].i = i; &#125; sort(a + 1, a + 1 + n); ret = 0; for (int i = 0; i &lt;= a[1].l; ++i) &#123; ret = (ret + C(a[1].r, i)) % mo; &#125; ans[a[1].i] = ret; l = a[1].l, r = a[1].r; for (int i = 2; i &lt;= n; ++i) &#123; for ( ; l &gt; a[i].l; ) --l, add(l, 0); for ( ; r &lt; a[i].r; ) ++r, add(r, 1); for ( ; l &lt; a[i].l; ) rem(l, 0), ++l; for ( ; r &gt; a[i].r; ) rem(r, 1), --r; ans[a[i].i] = ret; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", ans[i]); return 0;&#125; G. Depth-First Search题意： 给出一棵$n$个节点的无根树和一个长度为$n$的排列$B$。问有多少种dfs序在字典序上小于这个排列。 题解： 运用题解里提到的“逐位确定”的思想。首先，我们要知道，根的编号小于$B[1]$的方案数有多少种。不妨假设从$r$开始$(r&lt;B[1])$，那么可以树形dp出总方案数。表达式为 ans[r] = \\prod (cntchild[i]!) = deg[r] \\cdot \\prod_{i \\neq r} (deg[i] - 1)!那么，根节点比$B[1]$小的总答案为 ans1 = (\\prod_{i","path":"2018/08/03/2018hdu多校第4场补题/","date":"08-03","excerpt":""},{"title":"2018hdu多校第3场补题","text":"从易到难来写吧，其中题意有些直接摘了Claris的，数据范围是就不标了。如果需要可以去hdu题库里找。题号是6319 ～ 6331。 L. Visual Cube题意： 在画布上画一个三维立方体。 题解： 模拟即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, c, R, C;char g[505][505];int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; R = c * 2 + b * 2 + 1; C = a * 2 + b * 2 + 1; memset(g, '.', sizeof g); for (int i = R; i &gt;= R - c * 2; i -= 2) &#123; for (int j = 1; j &lt;= a; ++j) &#123; g[i][j * 2 - 1] = '+'; g[i][j * 2] = '-'; &#125; g[i][a * 2 + 1] = '+'; if (i == R - c * 2) continue; for (int j = 1; j &lt;= a; ++j) &#123; g[i - 1][j * 2 - 1] = '|'; &#125; g[i - 1][a * 2 + 1] = '|'; &#125; int ed = R, st = R - c * 2; for (int j = a * 2 + 1; j &lt;= C; ++j) &#123; int x = j - (a * 2); if (x &amp; 1) &#123; for (int i = st; i &lt;= ed; ++i) &#123; int y = ed - i; if (y &amp; 1) g[i][j] = '|'; else g[i][j] = '+'; &#125; &#125; else &#123; for (int i = st; i &lt;= ed; ++i) &#123; int y = ed - i; if (y &amp; 1) g[i][j] = '.'; else g[i][j] = '/'; &#125; &#125; --ed, --st; &#125; ed = b * 2 + 1, st = 1; for (int j = 1; j &lt;= a * 2; ++j) &#123; int x = j; if (x &amp; 1) &#123; for (int i = ed; i &gt;= st; --i) &#123; int y = i - st; if (y &amp; 1) g[i][j + ed - i] = '/'; else g[i][j + ed - i] = '+'; &#125; &#125; else &#123; for (int i = ed; i &gt;= st; --i) &#123; int y = i - st; if (y &amp; 1) ; else g[i][j + ed - i] = '-'; &#125; &#125; &#125; for (int i = 1; i &lt;= R; ++i) &#123; for (int j = 1; j &lt;= C; ++j) printf(\"%c\", g[i][j]); puts(\"\"); &#125; &#125; return 0;&#125; D. Euler Function题意： 求第$n$个使得$\\varphi(k)$为合数的$k$。 题解： 其实应该会有尝试，就是$n$到一定大小$\\varphi(k)$都是大于$2$的偶数，同时也是合数。其实找一下规律可以发现只有$k = 1, 2, 3, 6$时$\\varphi(k)$为质数。证明在Claris的题解里有写。 代码：123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main () &#123; int T,n; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); if (n==1) printf(\"5\\n\"); else printf(\"%d\\n\",5+n); &#125; return 0;&#125; F. Grab The Tree题意： 给定一棵$n$个点的树，每个点有权值。两个人玩游戏，先手需要占领若干不相邻的点，然后后手占领剩下所有点。每个人的得分为占领的点权异或和，分高的获胜。问最优策略下游戏的结果。 题解： 设$sum$为所有点权的异或和，$A$为先手得分，$B$为后手得分。若$sum=0$，则 $A=B$，怎样都是平局。否则考虑先手可以将原图分成两块，每一块里面的点都不相邻，然后取异或和较大的那块就好了，所以此时先手必胜。 代码：123456789101112131415#include&lt;bits/stdc++.h&gt;#define N 100010using namespace std;int main () &#123; int T,n,u,v,w; scanf(\"%d\",&amp;T); while (T--) &#123; int sum=0; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\",&amp;w),sum^=w; for(int i=1; i&lt;n; ++i) scanf(\"%d%d\",&amp;u,&amp;v); if (sum==0) printf(\"D\\n\"); else printf(\"Q\\n\"); &#125; return 0;&#125; C. Dynamic Graph Matching题意： 给定一个n个点的无向图，$m$次加边或者删边操作。在每次操作后统计有多少个匹配包含$k = 1, 2, …,\\frac n 2$条边。其中匹配是指不相交的边集。 题解： 设 f[i][S] 表示前i次操作，匹配点集为S的方案数。设当前边的两个端点为$x，y$。对于加边，显然有$f[i][S]=f[i-1][S]+f[i-1][S-x-y]。$其实，也可以直接省略第一维，执行$f[S]+=f[S-x-y]$。正确性是显然的。对于删边，由于前面加边的顺序无所谓，所以我们不妨设我们删除的正是上一次加入的边（为了方便理解）。这样，我们执行的就是一个你操作罢了：$f[S]-=f[S-x-y]$。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;const int mo = 1e9 + 7, N = 11;int n, m, bc[1 &lt;&lt; N], f[1 &lt;&lt; N], ans[N]; char op[5];int bitcnt (int x) &#123; return x ? bitcnt(x &gt;&gt; 1) + (x &amp; 1) : 0;&#125;int main () &#123; int T; cin &gt;&gt; T; for (int i = 0; i &lt; (1 &lt;&lt; N); ++i) bc[i] = bitcnt(i); for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m, f[0] = 1; for (int s = 1; s &lt; (1 &lt;&lt; n); ++s) f[s] = 0; for (int i = 1, x, y; i &lt;= m; ++i) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y), --x, --y; if (op[0] == '+') &#123; for (int s = 0, t; s &lt; (1 &lt;&lt; n); ++s) &#123; if ((s &gt;&gt; x &amp; 1) || (s &gt;&gt; y &amp; 1)) continue; t = s | 1 &lt;&lt; x | 1 &lt;&lt; y; f[t] += f[s]; if (f[t] &gt;= mo) f[t] -= mo; &#125; &#125; else &#123; for (int s = (1 &lt;&lt; n) - 1, t; ~s; --s) &#123; if ((s &gt;&gt; x &amp; 1) || (s &gt;&gt; y &amp; 1)) continue; t = s | 1 &lt;&lt; x | 1 &lt;&lt; y; f[t] -= f[s]; if (f[t] &lt; 0) f[t] += mo; &#125; &#125; for (int i = 1; i &lt;= (n &gt;&gt; 1); ++i) ans[i] = 0; for (int s = 1, t; s &lt; (1 &lt;&lt; n); ++s) &#123; t = bc[s]; if (t &amp; 1) continue; else t &gt;&gt;= 1; ans[t] += f[s]; if (ans[t] &gt;= mo) ans[t] -= mo; &#125; for (int i = 1; i &lt;= (n &gt;&gt; 1); ++i) &#123; printf(\"%d%c\", ans[i], i &lt; (n &gt;&gt; 1) ? ' ' : '\\n'); &#125; &#125; &#125; return 0;&#125; G. Interstellar Travel题意： 给定平面上$n$个点，起点横坐标最小，终点横坐标最大，所有点都在第一象限内。（包括坐标轴）每次可以飞到一个横坐标严格更大的点，代价为两个坐标的叉积。求起点到终点总代价最小的飞行路线，并输出字典序最小的路线。 题解： 因为叉积的几何意义就是有向平行四边形的面积的，然后根据题目给出的性质，很快就能反应过来，只需要维护一个凸包就好了（因为这个凸包面积最大，并且是负的，对应最小代价）。注意会有重点的问题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 200005;int n, top;struct point &#123; int x, y, i; point () &#123;&#125; point (int _x,int _y,int _i = 0) : x(_x), y(_y), i(_i) &#123;&#125;&#125; a[N], s[N];point operator - (point u, point v) &#123; return point(u.x - v.x, u.y - v.y, u.i);&#125;bool cmp (point u, point v) &#123; ll t = 1ll * u.x * v.y - 1ll * u.y * v.x; return t == 0 ? (u.x == v.x ? u.i &lt; v.i: u.x &lt; v.x) : t &lt; 0;&#125;bool cmp2 (point u, point v) &#123; ll t = 1ll * u.x * v.y - 1ll * u.y * v.x; return t == 0 ? u.i &lt; v.i : t &lt; 0;&#125;void solve () &#123; s[top = 1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i].x == a[i - 1].x &amp;&amp; a[i].y == a[i - 1].y) continue; while (top &gt;= 2 &amp;&amp; cmp2(a[i] - s[top - 1], s[top] - s[top - 1])) --top; s[++top] = a[i]; &#125;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); a[i].i = i; &#125; sort(a + 2, a + n, cmp); solve(); for (int i = 1; i &lt;= top; ++i) &#123; printf(\"%d%c\", s[i].i, i &lt; top ? ' ' : '\\n'); &#125; &#125; return 0;&#125; A. Ascending Rating题意： 给定一个序列$a[1..n]$，对于每个长度为$m$的连续子区间，求出区间$a$的最大值以及从左往右扫描该区间时$a$的最大值的变化次数。 题解： 这题反正来似乎比较容易。。考虑导致维护一个单调递减的单调队列，其中队列大小$size$就是当前区间最大值的变化次数，队列中最后一个元素就是区间最大值。具体想一想就好了。其实我是不会打单调数据结构的 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 10000005;int n, m, k, p, q, r, mo, a[N];int h, t, Q[N];ll A, B;int read () &#123; int x = 0; char ch = getchar(); for ( ; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for ( ; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - 48; return x;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p &gt;&gt; q &gt;&gt; r &gt;&gt; mo; for (int i = 1; i &lt;= k; ++i) a[i] = read(); for (int i = k + 1; i &lt;= n; ++i) a[i] = (1ll * p * a[i - 1] + 1ll * q * i + r) % mo; h = 0, t = 1, A = B = 0; for (int i = n; i &gt;= n - m + 1; --i) &#123; if (a[i] &lt; a[Q[h]]) Q[++h] = i; else &#123; for ( ; t &lt;= h &amp;&amp; a[i] &gt;= a[Q[h]]; ) --h; Q[++h] = i; &#125; &#125; A += a[Q[t]] ^ (n - m + 1); B += (h - t + 1) ^ (n - m + 1); for (int i = n - m; i; --i) &#123; if (Q[t] == i + m) ++t; if (a[i] &lt; a[Q[h]]) Q[++h] = i; else &#123; for ( ; t &lt;= h &amp;&amp; a[i] &gt;= a[Q[h]]; ) --h; Q[++h] = i; &#125; A += a[Q[t]] ^ i; B += (h - t + 1) ^ i; &#125; cout &lt;&lt; A &lt;&lt; \" \" &lt;&lt; B &lt;&lt; endl; &#125; return 0;&#125; I. Random Sequence题意： 给定一个正整数序列$a[1..n]$和一个$v$数组，每个数在$[1, m]$之间，有些数已知，有些数未知。求未知数随机填的情况下以下值的期望： \\begin{eqnarray*} \\prod_{i=1}^{n-3} v[\\gcd(a_i,a_{i+1},a_{i+2},a_{i+3})] \\end{eqnarray*} 题解： 观察下这题的数据范围，发现可以写个dp。$f[i][x][y][z]$表示将位置$1～i$（可能进行的）填数后，$a[i]=x，gcd(a[i],a[i-1])=y，gcd(a[i],a[i-1],a[i-2])=z$的期望答案（即套上连乘符号的）。则我们可以很轻松知道转移方程。但要注意的是这个连乘符号可能导致算期望的式子和我们平时做到的略有不同。总之，是有这样的式子： E[s] = V[s] * \\begin{eqnarray*} \\sum_{pre(s)}^{} E[pre]*pro[pre,s] \\end{eqnarray*}但别以为这样就完事了。注意到这样会MLE，所以你可以选择开滚动数组。然后你又被卡TLE了。注意到对于一个合法状态$(x，y，z)$，满足$z|y$且$y|x$。利用这个就可以简化状态数。然后你就稳了。注意前三项是不计贡献的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 105, mo = 1e9 + 7;int n, m, g[N][N], inv[N], a[N], v[N];int f[2][N][N][N];int ksm (int b, int p) &#123; if (p &lt; 2) return p ? b : 1; int t = ksm(b, p &gt;&gt; 1); t = 1ll * t * t % mo; return p &amp; 1 ? 1ll * t * b % mo : t;&#125;int main () &#123; int T; cin &gt;&gt; T; for (int i = 0; i &lt;= 100; ++i) g[0][i] = g[i][0] = i; for (int i = 1; i &lt;= 100; ++i) for (int j = 1; j &lt;= 100; ++j) g[i][j] = __gcd(i, j); for (int i = 1; i &lt;= 100; ++i) inv[i] = ksm(i, mo - 2); for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", &amp;v[i]); memset(f, 0, sizeof f); int nx, ny, nz, tmp; for (int z = 1; z &lt;= m; ++z) for (int y = 1; y &lt;= m; ++y) for (int x = 1; x &lt;= m; ++x) &#123; if (a[1] &amp;&amp; a[1] != z) continue; if (a[2] &amp;&amp; a[2] != y) continue; if (a[3] &amp;&amp; a[3] != x) continue; nx = x, ny = g[x][y], nz = g[ny][z]; tmp = 1; if (!a[1]) tmp = 1ll * tmp * inv[m] % mo; if (!a[2]) tmp = 1ll * tmp * inv[m] % mo; if (!a[3]) tmp = 1ll * tmp * inv[m] % mo; f[1][nx][ny][nz] += tmp; if (f[1][nx][ny][nz] &gt;= mo) f[1][nx][ny][nz] -= mo; &#125; for (int i = 3, c; i &lt;= n; ++i) &#123; c = i &amp; 1, memset(f[c ^ 1], 0, sizeof f[c ^ 1]); for (int z = 1; z &lt;= m; ++z) for (int y = z; y &lt;= m; y += z) for (int x = y; x &lt;= m; x += y) if (f[c][x][y][z]) &#123; if (a[i + 1]) &#123; nx = a[i + 1], ny = g[x][a[i + 1]], nz = g[y][a[i + 1]]; f[c ^ 1][nx][ny][nz] += 1ll * f[c][x][y][z] * v[g[a[i + 1]][z]] % mo; if (f[c ^ 1][nx][ny][nz] &gt;= mo) f[c ^ 1][nx][ny][nz] -= mo; continue; &#125; for (int j = 1; j &lt;= m; ++j) &#123; nx = j, ny = g[x][j], nz = g[y][j]; f[c ^ 1][nx][ny][nz] += 1ll * f[c][x][y][z] * v[g[j][z]] % mo * inv[m] % mo; if (f[c ^ 1][nx][ny][nz] &gt;= mo) f[c ^ 1][nx][ny][nz] -= mo; &#125; &#125; &#125; int ans = 0; for (int z = 1; z &lt;= m; ++z) for (int y = z; y &lt;= m; y += z) for (int x = y; x &lt;= m; x += y) ans = (ans + f[n &amp; 1][x][y][z]) % mo; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; M. Walking Plan题意： 给定一个$n$个点，$m$条边的有向图，$q$次询问$s$到$t$经过至少$k$条边的最短路。 题解： 注意观察数据范围。显然可以预处理出$f[k][i][j]$表示i经过恰好k条边到达j的最短路。转移方程：$f[k][i][j]=min(f[k−1][i][x]+w[x][j])$。（看f[k]长得很像个矩阵，不过这题并不用这个性质）当然你可以选择用$O(n^3 * 10000)$的时间预处理，然后愉快地gg了。当然还有更好的选择。我们来分块！我们预处理出$f[k][i][j]$表示i经过恰好k条边到达j的最短路，其中$0&lt;=k&lt;=100$。再预处理出$g[k][i][j]$表示i经过恰好100k条边到达j的最短路，其中$0&lt;=k&lt;=100$。对于一个询问，设$A = k / 100$，$B$ $=$ $k$ $mod$ $100$。则我们枚举中间点，$ans=min(a[A][s][x]+b[B][x][t])$。这样是不是就好了？错！题目中要求的是至少经过$k$条边，而非恰好。所以我们在$b$数组中做点手脚。其实就是先跑出原图的最短路，然后以“恰当的方式”更新$b$数组就好了。这个恰当的方式可以参考一下具体实现。复杂度是$O(n^3 \\sqrt k+ nq)$。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55, K = 10005, S = 105, inf = 0x3f3f3f3f;int n, m, q, ans, g[N][N], f[N][N], A[S][N][N], B[S][N][N];int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m; memset(g, 0x3f, sizeof g); memset(A, 0x3f, sizeof A); memset(B, 0x3f, sizeof B); for (int i = 1, x, y, z; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); g[x][y] = min(g[x][y], z); B[1][x][y] = g[x][y]; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) A[0][i][j] = B[0][i][j] = i == j ? 0 : inf; for (int k = 2; k &lt;= 100; ++k) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int x = 1; x &lt;= n; ++x) B[k][i][j] = min(B[k][i][j], B[k - 1][i][x] + B[1][x][j]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) A[1][i][j] = B[100][i][j]; &#125; for (int k = 2; k &lt;= 100; ++k) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int x = 1; x &lt;= n; ++x) A[k][i][j] = min(A[k][i][j], A[k - 1][i][x] + A[1][x][j]); &#125; for (int i = 1; i &lt;= n; i++) g[i][i] = 0; for (int x = 1; x &lt;= n; ++x) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) g[i][j] = min(g[i][j], g[i][x] + g[x][j]); &#125; &#125; for (int k = 0; k &lt;= 100; ++k) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = inf; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int x = 1; x &lt;= n; ++x) f[i][j] = min(f[i][j], B[k][i][x] + g[x][j]); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) B[k][i][j] = f[i][j]; &#125; cin &gt;&gt; q; for (int s, t, k, u, v; q; --q) &#123; scanf(\"%d%d%d\", &amp;s, &amp;t, &amp;k), ans = inf; u = k / 100, v = k % 100; for (int i = 1; i &lt;= n; ++i) &#123; ans = min(ans, A[u][s][i] + B[v][i][t]); &#125; if (ans &gt;= inf) ans = -1; printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125; H. Monster Hunter题意： 给定一棵$n$个点的树，除$1$外每个点有一只怪兽，打败它需要先消耗$a[i]$点 HP，再恢复$b[i]$点 HP。求从$1$号点出发按照最优策略打败所有怪兽一开始所需的最少HP（其中，过程中不能出现HP为负的情况）。 题解： 这题教会了我们从简单的情况思考。假设没有“树”的限制，即没有定死的先后顺序。怎么办？显然贪心。将怪兽分成两类考虑：$a &lt; b$和$a&gt;=b$。其实这种贪心见到过不止一次显然应该先打前一类，再打后一类。前一类的显然是先打a小的。可以感性理解一下。其实很好证，时间关系，不证了。后一类呢，稍微要想一想。我就拖一下Claris的证明吧：对于$a&gt;=b$的怪兽，考虑两只怪兽$i$,$j$。先打$i$再打$j$: $HPmin=HP - a[i] + b[i] - a[j] $先打$j$再打$i$: $HPmin=HP - a[j] + b[j] - a[i] $这样的话，我们必定会选择$b$大的先打。再回头考虑原问题。设排好序后，顺序为$p[1]，p[2]，…，p[n]$若$p[1] = 1$，那么第一步打$p[1]$一定最优。否则在打完$p[1]$的父亲$fa$后，紧接着打$p[1]$一定最优。直接合并它们。剩下的是规模为$n-1$的子问题。注意这里合并和快速搜索最优分别要用到并查集和堆。复杂度是$O(nlogn)$的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define mp make_pair#define ll long longusing namespace std;const int N = 100005;int n, P, a[N], b[N];int tot, lnk[N], nxt[N &lt;&lt; 1], son[N &lt;&lt; 1], fa[N];bool dead[N];struct mons &#123; ll a, b; int i, t; mons () &#123;&#125; mons (ll _a, ll _b, int _i = 0,int _t = 0) : a(_a), b(_b), i(_i), t(_t) &#123;&#125; bool operator &lt; (const mons &amp;o) const &#123; bool k1 = a &lt; b, k2 = o.a &lt; o.b; if (k1 != k2) return k1 &lt; k2; else return a &gt;= b ? b &lt; o.b : a &gt; o.a; &#125; void operator += (const mons &amp;o) &#123; ll na = max(a, a - b + o.a), nb = - a + b - o.a + o.b + na; a = na, b = nb; &#125;&#125; m[N], cur;priority_queue &lt;mons&gt; q;int read () &#123; int x = 0; char ch = getchar(); for ( ; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for ( ; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - 48; return x;&#125;void add (int x, int y) &#123; nxt[++tot] = lnk[x], lnk[x] = tot, son[tot] = y;&#125;void dfs (int x, int p) &#123; fa[x] = p; for (int j = lnk[x]; j; j = nxt[j]) &#123; if (son[j] == p) continue; dfs(son[j], x); &#125;&#125;int get (int x) &#123; return dead[fa[x]] ? fa[x] = get(fa[x]) : fa[x];&#125;int main () &#123; for (int T = read(); T; --T) &#123; n = read(), tot = 0; for (int i = 1; i &lt;= n; ++i) lnk[i] = 0, dead[i] = 0; for (int i = 1; i &lt;= n * 2; ++i) nxt[i] = 0; for ( ; !q.empty(); q.pop()); m[1] = mons(0, 0, 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; m[i].a = read(), m[i].b = read(); m[i].i = i, m[i].t = 0, q.push(m[i]); &#125; for (int i = 1, x, y; i &lt; n; ++i) &#123; x = read(), y = read(); add(x, y), add(y, x); &#125; dfs(1, 0), dead[1] = 0; for (int sec = 1; !q.empty(); ++sec) &#123; cur = q.top(), q.pop(); if (cur.t != m[cur.i].t || dead[cur.i]) continue; get(cur.i), dead[cur.i] = 1; P = get(cur.i); m[P] += m[cur.i], m[P].t = sec; if (P &gt; 1) q.push(m[P]); &#125; cout &lt;&lt; max(0ll, m[1].a) &lt;&lt; endl; &#125; return 0;&#125; 剩下的题可能有点难搞了。。","path":"2018/08/01/2018hdu多校第3场补题/","date":"08-01","excerpt":""}]}