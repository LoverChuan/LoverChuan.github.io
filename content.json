{"pages":[{"title":"categories","text":"","path":"categories/index.html","date":"03-24","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"03-24","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-24","excerpt":""},{"title":"404","text":"","path":"404/index-1.html","date":"03-24","excerpt":""},{"title":"about","text":"这是我的第三个博客，前两个分别在博客园和WordPress上，但实在自由空间太少了。还是Github好！来自浙江江山的一只小OIer。求学轨迹：江山实验小学--&gt;江山二中--&gt;杭州学军中学。（吐槽一句，进XJ容易，活下来难QAQ）是一只热爱学(隔)习(膜)的小蒟蒻，已经是OIer龄已有3年，但依然很菜。文化课现在连装B都不行了，菜到对不住我自己つ﹏⊂爱好说广泛也并不广，最爱足球，立场萨米+kop，当然作为一个理性的球迷，当然什么都喜欢，只是偏好而已。挂一张梅老板的图~~欢迎侃球QQ ：1121147896Email ：w.h.chuan@foxmail.comBlog ：loverchuan.github.io","path":"about/index.html","date":"03-25","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-24","excerpt":""}],"posts":[{"title":"2018hdu多校第4场补题","text":"自己学校出的毒瘤场。。吃枣药丸hdu中的题号是6332 ～ 6343。 K. Expression in Memories题意： 判断一个简化版的算术表达式是否合法。 题解： 注意细节即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int n; char s[505];int main () &#123; int T; cin&gt;&gt;T; for ( ; T; --T) &#123; scanf(\"%s\",s+1),n=strlen(s+1),s[0]='+'; if (s[1]=='?') s[1]='9'; bool ok=1; for (int i=2; i&lt;=n; ++i) &#123; if (s[i]=='+'||s[i]=='*') &#123; if (s[i-1]=='+'||s[i-1]=='*') &#123;ok=0; break;&#125; &#125; else if (s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') &#123; if (s[i-1]=='0'&amp;&amp;(s[i-2]=='+'||s[i-2]=='*')) &#123;ok=0; break;&#125; &#125; else if (s[i]=='?') &#123; if (s[i-1]=='+'||s[i-1]=='*') s[i]='9'; else if (s[i-1]=='0') &#123; if (s[i-2]=='+'||s[i-2]=='*') s[i]='+'; else s[i]='9'; &#125; else if (s[i-1]&gt;='1'&amp;&amp;s[i-1]&lt;='9') s[i]='9'; &#125; &#125; if (s[n]=='+'||s[n]=='*'||s[1]=='+'||s[1]=='*') ok=0; if (n&gt;=2) &#123; if (s[1]=='0'&amp;&amp;s[2]&gt;='0'&amp;&amp;s[2]&lt;='9') ok=0; &#125; if (!ok) puts(\"IMPOSSIBLE\"); else &#123; for (int i=1; i&lt;=n; ++i) printf(\"%c\",s[i]); puts(\"\"); &#125; &#125; return 0;&#125; L. Graph Theory Homework题意： 给你一张每个点有点权的完全图。从点$i$走到点$j$ $（i≠j）$的代价为 $\\lfloor \\sqrt {|wi-wj|} \\rfloor$球从$1$走到$n$的最小代价。 题解： 一个不等式： $\\lfloor \\sqrt {a} \\rfloor + \\lfloor \\sqrt {b} \\rfloor \\geq \\lfloor \\sqrt {a+b} \\rfloor$则，从$1$不经过任何点直接到$n$是最优的。 代码：1234567891011121314#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N],w2[N];int main () &#123; int T,n; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\",&amp;w[i]); printf(\"%d\\n\",(int)sqrt(abs(w[n]-w[1]))); &#125; return 0;&#125; D. Nothing is Impossible题意： 没有题意，至今还不知道最终的题意。 题解： 没有题解，只需要大胆猜想，无需证明，取最小的几个$bi$使得$\\prod {(bi + 1)} \\leq m$就行了。能取到的最多个数就是答案。 代码：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int b[105];int main()&#123; int T, n, m, x; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = n; long long now = 1; for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;x, &amp;b[i]); sort(b + 1, b + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; if (now * (b[i] + 1) &gt; m) &#123;ans = i - 1; break;&#125; now *= (b[i] + 1); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; E. Matrix from Arrays题意： 给你一个$L$个元素的数组$A$，根据题意构造一个无限矩阵，并进行$q$次询问，询问一个有限矩阵内的元素和。 题解： 容易发现，构造出来的无限矩阵是一个循环矩阵。当$L$是奇数时，矩阵每${L} \\cdot {L}$个元素循环；当$L$是偶数时，矩阵每${2L} * {2L}$个元素循环。这样我们就可以预处理处一个很小（边长$80$以内)的矩阵，然后做一下前缀和。最后询问的时候留给我们解决的也不多了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int L, Q; ll A[20], M[90][90], s1[90], s2[90], sum;ll calc (int x, int y, ll ret = 0) &#123; ll k1 = (x + 1) / (2 * L), k2 = (y + 1) / (2 * L); ll o1 = (x + 1) % (2 * L), o2 = (y + 1) % (2 * L); ret += sum * k1 * k2; if (o1) ret += s1[o1 - 1] * k2; if (o2) ret += s2[o2 - 1] * k1; for (int i = 0; i &lt; o1; ++i) &#123; for (int j = 0; j &lt; o2; ++j) ret += M[i][j]; &#125; return ret;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; L; for (int i = 0; i &lt; L; ++i) cin &gt;&gt; A[i]; int cursor = 0; for (int i = 0; i &lt; 4 * L; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; M[j][i - j] = A[cursor]; cursor = (cursor + 1) % L; &#125; &#125; sum = 0; for (int i = 0; i &lt; 2 * L; ++i) &#123; for (int j = 0; j &lt; 2 * L; ++j) sum += M[i][j]; &#125; memset(s1, 0, sizeof s1); memset(s2, 0, sizeof s2); for (int i = 0; i &lt; 2 * L; ++i) &#123; for (int j = 0; j &lt; 2 * L; ++j) s1[i] += M[i][j]; if (i) s1[i] += s1[i - 1]; &#125; for (int j = 0; j &lt; 2 * L; ++j) &#123; for (int i = 0; i &lt; 2 * L; ++i) s2[j] += M[i][j]; if (j) s2[j] += s2[j - 1]; &#125; cin &gt;&gt; Q; for ( ; Q; --Q) &#123; int l, u, r, d; scanf(\"%d%d%d%d\", &amp;l, &amp;u, &amp;r, &amp;d); printf(\"%lld\\n\", calc(r, d) - calc(r, u - 1) - calc(l - 1, d) + calc(l - 1, u - 1)); &#125; &#125; return 0;&#125; J. Let Sudoku Rotate题意： 有一个合法的$4$阶数独，某人随机把几个“宫”分别逆时针翻转了几次，先给出现在的数独，问那个人总共最少转了几次。 题解： 如果你够大胆，就去爆搜吧；如果你不够大胆，就去$dlx$吧！反正都能过，可能是因为合法情况太少的缘故 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 17, M = 5;int n, m, ans, a[N][N], tmp[M][M]; char s[N];int R[N][N], C[N][N];void rotating_lalala (int r, int c) &#123; int _u = r * m, _d = _u + m, _l = c * m, _r = _l + m; for (int i = _u; i &lt; _d; ++i) for (int j = _l; j &lt; _r; ++j) tmp[j - _l][m - (i - _u) - 1] = a[i][j]; for (int i = _u; i &lt; _d; ++i) for (int j = _l; j &lt; _r; ++j) a[i][j] = tmp[i - _u][j - _l];&#125;bool exam (int r, int c) &#123; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int x = r * m + i, y = c * m + j; if (R[x][a[x][y]]) return 0; if (C[y][a[x][y]]) return 0; &#125; &#125; return 1;&#125;void fig (int r, int c, int d) &#123; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int x = r * m + i, y = c * m + j; R[x][a[x][y]] += d, C[y][a[x][y]] += d; &#125; &#125;&#125;void dfs (int r, int c, int cnt) &#123; if (cnt &gt;= ans) return; if (c == m) c = 0, ++r; if (r == m &amp;&amp; c == 0) &#123;ans = cnt; return;&#125; if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 0), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 1), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 2), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 3), fig(r, c, -1); rotating_lalala(r, c);&#125;int main () &#123; int T; cin &gt;&gt; T; m = 4, n = 16; for ( ; T; --T) &#123; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%s\", s); for (int j = 0; j &lt; n; ++j) &#123; if (s[j] &gt;= '0' &amp;&amp; s[j] &lt;= '9') a[i][j] = s[j] - '0'; else a[i][j] = s[j] - 'A' + 10; &#125; &#125; ans = 64; memset(R, 0, sizeof R), memset(C, 0, sizeof C); dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B. Harvest of Apples题意： 求$\\sum_{i=0}^{m} {C_{n}^{i}}$，$n，m$都是$1e5$范围，还有$1e5$组询问。 题解： 早就见识过这个东西的厉害。但一起一直不知道怎么做。也不知道有没有柿子。然后就去$OEIS$了一发，结果什么都没有。。OEIS大法失灵了 还是我等蒟蒻不会用。考场上想过离线，也想过$n$和$n-1$，$m$和$m-1$的关系，但是就没有想到莫队。首先，设$S(n, m) = \\sum_{i=0}^{m} {C_{n}^{i}}$，利用杨辉三角那个公式，我们有柿子：$S(n, m) = S(n, m - 1) + C_{n}^{m}$$S(n, m) = 2 * S(n - 1, m) - C_{n-1}^{m}$这样我们发现，等式两边给出的两对关系，让我们真的可以愉快地搞莫队了。而且很好码，双倍的快乐嘻嘻嘻转移复杂度是$O(1)$的。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 100005, mo = 1e9 + 7, inv2 = 500000004;int n, siz, l, r; ll ret, fac[N], inv[N], ans[N];struct que &#123; int l, r, i; bool operator &lt; (const que &amp;o) const &#123; return (r - 1) / siz == (o.r - 1) / siz ? l &lt; o.l : r &lt; o.r; &#125;&#125; a[N];ll ksm (ll b, ll p) &#123; if (p &lt; 2) return p ? b : 1; ll t = ksm(b, p &gt;&gt; 1); t = t * t % mo; return p &amp; 1 ? t * b % mo : t;&#125;ll C (int n, int r) &#123; if (r &lt; 0 || n &lt; r) return 0; return fac[n] * inv[r] % mo * inv[n - r] % mo;&#125;void ppw () &#123; fac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = fac[i - 1] * i % mo; inv[N - 1] = ksm(fac[N - 1], mo - 2); for (int i = N - 2; ~i; --i) inv[i] = inv[i + 1] * (i + 1) % mo;&#125;void add (int x, bool o) &#123; if (!o) ret -= C(r, l + 1); else ret = ret * 2 - C(r - 1, l); ret = (ret + mo) % mo;&#125;void rem (int x, bool o) &#123; if (!o) ret += C(r, l + 1); else ret = (ret + C(r - 1, l)) * inv2; ret = ret % mo;&#125;int main () &#123; cin &gt;&gt; n, siz = sqrt(n + 0.5), ppw(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].r, &amp;a[i].l); a[i].i = i; &#125; sort(a + 1, a + 1 + n); ret = 0; for (int i = 0; i &lt;= a[1].l; ++i) &#123; ret = (ret + C(a[1].r, i)) % mo; &#125; ans[a[1].i] = ret; l = a[1].l, r = a[1].r; for (int i = 2; i &lt;= n; ++i) &#123; for ( ; l &gt; a[i].l; ) --l, add(l, 0); for ( ; r &lt; a[i].r; ) ++r, add(r, 1); for ( ; l &lt; a[i].l; ) rem(l, 0), ++l; for ( ; r &gt; a[i].r; ) rem(r, 1), --r; ans[a[i].i] = ret; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", ans[i]); return 0;&#125; G. Depth-First Search题意： 给出一棵$n$个节点的无根树和一个长度为$n$的排列$B$。问有多少种dfs序在字典序上小于这个排列。 题解： 运用题解里提到的“逐位确定”的思想。首先，我们要知道，根的编号小于$B[1]$的方案数有多少种。不妨假设从$r$开始$(r&lt;B[1])$，那么可以树形dp出总方案数。表达式为 ans[r] = \\prod (cntchild[i]!) = deg[r] \\cdot \\prod_{i \\neq r} (deg[i] - 1)!那么，根节点比$B[1]$小的总答案为 ans1 = (\\prod_{i","path":"2018/09/07/2018hdu多校第4场补题/","date":"09-07","excerpt":""},{"title":"newtest","text":"新生！hey！","path":"2018/09/07/newtest/","date":"09-07","excerpt":""},{"title":"Test","text":"It is only A test.(我好菜啊，完全不会MarkDown。。) 我是超链接-&gt;luogu 苟利国家生死以，岂因祸福避趋之 苟利国家生死以，岂因祸福避趋之 苟利国家生死以，岂因祸福避趋之 12345678#include &lt;cstdio&gt;using namespace std;int main () &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",a+b); return 0;&#125; 据说有‘行内代码‘这种操作？！好像没有搞出来233update 有了还有数学公式什么的，以后再搞，要回去了。。现在似乎还有代码高亮和数学公式没怎么测试。","path":"2018/03/25/test/","date":"03-25","excerpt":""}]}