{"pages":[{"title":"404","text":"","path":"404/index-1.html","date":"03-24","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"03-24","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-24","excerpt":""},{"title":"about","text":"这是我的第三个博客，前两个分别在`博客园`和`WordPress`上，但实在自由空间太少了。还是Github好！ 来自`浙江江山`的一只小`OIer`。 求学轨迹：`江山实验小学-->江山二中-->杭州学军中学`。（吐槽一句，进XJ容易，活下来难QAQ） 是一只热爱学(隔)习(膜)的`小蒟蒻`，已经是OIer龄已有3年，但依然很菜。 文化课现在连装B都不行了，菜到对不住我自己つ﹏⊂ 爱好说广泛也并不广，最爱足球，立场`萨米+kop`，当然作为一个理性的球迷，当然什么都喜欢，只是偏好而已。 挂一张梅老板的图~~欢迎侃球 ![Messi](graphlib/messi.jpg) QQ ：1121147896 Email ：w.h.chuan@foxmail.com Blog ：loverchuan.github.io","path":"about/index.html","date":"03-25","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-24","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-24","excerpt":""}],"posts":[{"title":"2018hdu多校第4场补题","text":"自己学校出的毒瘤场。。吃枣药丸hdu中的题号是6332 ～ 6343。 K. Expression in Memories题意： 判断一个简化版的算术表达式是否合法。 题解： 注意细节即可。 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int n; char s[505];int main () &#123; int T; cin&gt;&gt;T; for ( ; T; --T) &#123; scanf(\"%s\",s+1),n=strlen(s+1),s[0]='+'; if (s[1]=='?') s[1]='9'; bool ok=1; for (int i=2; i&lt;=n; ++i) &#123; if (s[i]=='+'||s[i]=='*') &#123; if (s[i-1]=='+'||s[i-1]=='*') &#123;ok=0; break;&#125; &#125; else if (s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') &#123; if (s[i-1]=='0'&amp;&amp;(s[i-2]=='+'||s[i-2]=='*')) &#123;ok=0; break;&#125; &#125; else if (s[i]=='?') &#123; if (s[i-1]=='+'||s[i-1]=='*') s[i]='9'; else if (s[i-1]=='0') &#123; if (s[i-2]=='+'||s[i-2]=='*') s[i]='+'; else s[i]='9'; &#125; else if (s[i-1]&gt;='1'&amp;&amp;s[i-1]&lt;='9') s[i]='9'; &#125; &#125; if (s[n]=='+'||s[n]=='*'||s[1]=='+'||s[1]=='*') ok=0; if (n&gt;=2) &#123; if (s[1]=='0'&amp;&amp;s[2]&gt;='0'&amp;&amp;s[2]&lt;='9') ok=0; &#125; if (!ok) puts(\"IMPOSSIBLE\"); else &#123; for (int i=1; i&lt;=n; ++i) printf(\"%c\",s[i]); puts(\"\"); &#125; &#125; return 0;&#125; L. Graph Theory Homework题意： 给你一张每个点有点权的完全图。从点$i$走到点$j$ $（i≠j）$的代价为 $\\lfloor \\sqrt {|wi-wj|} \\rfloor$球从$1$走到$n$的最小代价。 题解： 一个不等式： $\\lfloor \\sqrt {a} \\rfloor + \\lfloor \\sqrt {b} \\rfloor \\geq \\lfloor \\sqrt {a+b} \\rfloor$则，从$1$不经过任何点直接到$n$是最优的。 代码：1234567891011121314#include &lt;bits/stdc++.h&gt;#define N 100010using namespace std;int w[N],w2[N];int main () &#123; int T,n; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\",&amp;w[i]); printf(\"%d\\n\",(int)sqrt(abs(w[n]-w[1]))); &#125; return 0;&#125; D. Nothing is Impossible题意： 没有题意，至今还不知道最终的题意。 题解： 没有题解，只需要大胆猜想，无需证明，取最小的几个$bi$使得$\\prod {(bi + 1)} \\leq m$就行了。能取到的最多个数就是答案。 代码：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int b[105];int main()&#123; int T, n, m, x; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); int ans = n; long long now = 1; for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;x, &amp;b[i]); sort(b + 1, b + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; if (now * (b[i] + 1) &gt; m) &#123;ans = i - 1; break;&#125; now *= (b[i] + 1); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; E. Matrix from Arrays题意： 给你一个$L$个元素的数组$A$，根据题意构造一个无限矩阵，并进行$q$次询问，询问一个有限矩阵内的元素和。 题解： 容易发现，构造出来的无限矩阵是一个循环矩阵。当$L$是奇数时，矩阵每${L} \\cdot {L}$个元素循环；当$L$是偶数时，矩阵每${2L} * {2L}$个元素循环。这样我们就可以预处理处一个很小（边长$80$以内)的矩阵，然后做一下前缀和。最后询问的时候留给我们解决的也不多了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int L, Q; ll A[20], M[90][90], s1[90], s2[90], sum;ll calc (int x, int y, ll ret = 0) &#123; ll k1 = (x + 1) / (2 * L), k2 = (y + 1) / (2 * L); ll o1 = (x + 1) % (2 * L), o2 = (y + 1) % (2 * L); ret += sum * k1 * k2; if (o1) ret += s1[o1 - 1] * k2; if (o2) ret += s2[o2 - 1] * k1; for (int i = 0; i &lt; o1; ++i) &#123; for (int j = 0; j &lt; o2; ++j) ret += M[i][j]; &#125; return ret;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; L; for (int i = 0; i &lt; L; ++i) cin &gt;&gt; A[i]; int cursor = 0; for (int i = 0; i &lt; 4 * L; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; M[j][i - j] = A[cursor]; cursor = (cursor + 1) % L; &#125; &#125; sum = 0; for (int i = 0; i &lt; 2 * L; ++i) &#123; for (int j = 0; j &lt; 2 * L; ++j) sum += M[i][j]; &#125; memset(s1, 0, sizeof s1); memset(s2, 0, sizeof s2); for (int i = 0; i &lt; 2 * L; ++i) &#123; for (int j = 0; j &lt; 2 * L; ++j) s1[i] += M[i][j]; if (i) s1[i] += s1[i - 1]; &#125; for (int j = 0; j &lt; 2 * L; ++j) &#123; for (int i = 0; i &lt; 2 * L; ++i) s2[j] += M[i][j]; if (j) s2[j] += s2[j - 1]; &#125; cin &gt;&gt; Q; for ( ; Q; --Q) &#123; int l, u, r, d; scanf(\"%d%d%d%d\", &amp;l, &amp;u, &amp;r, &amp;d); printf(\"%lld\\n\", calc(r, d) - calc(r, u - 1) - calc(l - 1, d) + calc(l - 1, u - 1)); &#125; &#125; return 0;&#125; J. Let Sudoku Rotate题意： 有一个合法的$4$阶数独，某人随机把几个“宫”分别逆时针翻转了几次，先给出现在的数独，问那个人总共最少转了几次。 题解： 如果你够大胆，就去爆搜吧；如果你不够大胆，就去$dlx$吧！反正都能过，可能是因为合法情况太少的缘故 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 17, M = 5;int n, m, ans, a[N][N], tmp[M][M]; char s[N];int R[N][N], C[N][N];void rotating_lalala (int r, int c) &#123; int _u = r * m, _d = _u + m, _l = c * m, _r = _l + m; for (int i = _u; i &lt; _d; ++i) for (int j = _l; j &lt; _r; ++j) tmp[j - _l][m - (i - _u) - 1] = a[i][j]; for (int i = _u; i &lt; _d; ++i) for (int j = _l; j &lt; _r; ++j) a[i][j] = tmp[i - _u][j - _l];&#125;bool exam (int r, int c) &#123; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int x = r * m + i, y = c * m + j; if (R[x][a[x][y]]) return 0; if (C[y][a[x][y]]) return 0; &#125; &#125; return 1;&#125;void fig (int r, int c, int d) &#123; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int x = r * m + i, y = c * m + j; R[x][a[x][y]] += d, C[y][a[x][y]] += d; &#125; &#125;&#125;void dfs (int r, int c, int cnt) &#123; if (cnt &gt;= ans) return; if (c == m) c = 0, ++r; if (r == m &amp;&amp; c == 0) &#123;ans = cnt; return;&#125; if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 0), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 1), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 2), fig(r, c, -1); rotating_lalala(r, c); if (exam(r, c)) fig(r, c, 1), dfs(r, c + 1, cnt + 3), fig(r, c, -1); rotating_lalala(r, c);&#125;int main () &#123; int T; cin &gt;&gt; T; m = 4, n = 16; for ( ; T; --T) &#123; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%s\", s); for (int j = 0; j &lt; n; ++j) &#123; if (s[j] &gt;= '0' &amp;&amp; s[j] &lt;= '9') a[i][j] = s[j] - '0'; else a[i][j] = s[j] - 'A' + 10; &#125; &#125; ans = 64; memset(R, 0, sizeof R), memset(C, 0, sizeof C); dfs(0, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B. Harvest of Apples题意： 求$\\sum_{i=0}^{m} {C_{n}^{i}}$，$n，m$都是$1e5$范围，还有$1e5$组询问。 题解： 早就见识过这个东西的厉害。但一起一直不知道怎么做。也不知道有没有柿子。然后就去$OEIS$了一发，结果什么都没有。。OEIS大法失灵了 还是我等蒟蒻不会用。考场上想过离线，也想过$n$和$n-1$，$m$和$m-1$的关系，但是就没有想到莫队。首先，设$S(n, m) = \\sum_{i=0}^{m} {C_{n}^{i}}$，利用杨辉三角那个公式，我们有柿子：$S(n, m) = S(n, m - 1) + C_{n}^{m}$$S(n, m) = 2 * S(n - 1, m) - C_{n-1}^{m}$这样我们发现，等式两边给出的两对关系，让我们真的可以愉快地搞莫队了。而且很好码，双倍的快乐嘻嘻嘻转移复杂度是$O(1)$的。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 100005, mo = 1e9 + 7, inv2 = 500000004;int n, siz, l, r; ll ret, fac[N], inv[N], ans[N];struct que &#123; int l, r, i; bool operator &lt; (const que &amp;o) const &#123; return (r - 1) / siz == (o.r - 1) / siz ? l &lt; o.l : r &lt; o.r; &#125;&#125; a[N];ll ksm (ll b, ll p) &#123; if (p &lt; 2) return p ? b : 1; ll t = ksm(b, p &gt;&gt; 1); t = t * t % mo; return p &amp; 1 ? t * b % mo : t;&#125;ll C (int n, int r) &#123; if (r &lt; 0 || n &lt; r) return 0; return fac[n] * inv[r] % mo * inv[n - r] % mo;&#125;void ppw () &#123; fac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = fac[i - 1] * i % mo; inv[N - 1] = ksm(fac[N - 1], mo - 2); for (int i = N - 2; ~i; --i) inv[i] = inv[i + 1] * (i + 1) % mo;&#125;void add (int x, bool o) &#123; if (!o) ret -= C(r, l + 1); else ret = ret * 2 - C(r - 1, l); ret = (ret + mo) % mo;&#125;void rem (int x, bool o) &#123; if (!o) ret += C(r, l + 1); else ret = (ret + C(r - 1, l)) * inv2; ret = ret % mo;&#125;int main () &#123; cin &gt;&gt; n, siz = sqrt(n + 0.5), ppw(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].r, &amp;a[i].l); a[i].i = i; &#125; sort(a + 1, a + 1 + n); ret = 0; for (int i = 0; i &lt;= a[1].l; ++i) &#123; ret = (ret + C(a[1].r, i)) % mo; &#125; ans[a[1].i] = ret; l = a[1].l, r = a[1].r; for (int i = 2; i &lt;= n; ++i) &#123; for ( ; l &gt; a[i].l; ) --l, add(l, 0); for ( ; r &lt; a[i].r; ) ++r, add(r, 1); for ( ; l &lt; a[i].l; ) rem(l, 0), ++l; for ( ; r &gt; a[i].r; ) rem(r, 1), --r; ans[a[i].i] = ret; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", ans[i]); return 0;&#125; G. Depth-First Search题意： 给出一棵$n$个节点的无根树和一个长度为$n$的排列$B$。问有多少种dfs序在字典序上小于这个排列。 题解： 运用题解里提到的“逐位确定”的思想。首先，我们要知道，根的编号小于$B[1]$的方案数有多少种。不妨假设从$r$开始$(r&lt;B[1])$，那么可以树形dp出总方案数。表达式为 ans[r] = \\prod (cntchild[i]!) = deg[r] \\cdot \\prod_{i \\neq r} (deg[i] - 1)!那么，根节点比$B[1]$小的总答案为 ans1 = (\\prod_{i","path":"2018/08/03/2018hdu多校第4场补题/","date":"08-03","excerpt":""},{"title":"2018hdu多校第3场补题","text":"从易到难来写吧，其中题意有些直接摘了Claris的，数据范围是就不标了。如果需要可以去hdu题库里找。题号是6319 ～ 6331。 L. Visual Cube题意： 在画布上画一个三维立方体。 题解： 模拟即可。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, c, R, C;char g[505][505];int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; R = c * 2 + b * 2 + 1; C = a * 2 + b * 2 + 1; memset(g, '.', sizeof g); for (int i = R; i &gt;= R - c * 2; i -= 2) &#123; for (int j = 1; j &lt;= a; ++j) &#123; g[i][j * 2 - 1] = '+'; g[i][j * 2] = '-'; &#125; g[i][a * 2 + 1] = '+'; if (i == R - c * 2) continue; for (int j = 1; j &lt;= a; ++j) &#123; g[i - 1][j * 2 - 1] = '|'; &#125; g[i - 1][a * 2 + 1] = '|'; &#125; int ed = R, st = R - c * 2; for (int j = a * 2 + 1; j &lt;= C; ++j) &#123; int x = j - (a * 2); if (x &amp; 1) &#123; for (int i = st; i &lt;= ed; ++i) &#123; int y = ed - i; if (y &amp; 1) g[i][j] = '|'; else g[i][j] = '+'; &#125; &#125; else &#123; for (int i = st; i &lt;= ed; ++i) &#123; int y = ed - i; if (y &amp; 1) g[i][j] = '.'; else g[i][j] = '/'; &#125; &#125; --ed, --st; &#125; ed = b * 2 + 1, st = 1; for (int j = 1; j &lt;= a * 2; ++j) &#123; int x = j; if (x &amp; 1) &#123; for (int i = ed; i &gt;= st; --i) &#123; int y = i - st; if (y &amp; 1) g[i][j + ed - i] = '/'; else g[i][j + ed - i] = '+'; &#125; &#125; else &#123; for (int i = ed; i &gt;= st; --i) &#123; int y = i - st; if (y &amp; 1) ; else g[i][j + ed - i] = '-'; &#125; &#125; &#125; for (int i = 1; i &lt;= R; ++i) &#123; for (int j = 1; j &lt;= C; ++j) printf(\"%c\", g[i][j]); puts(\"\"); &#125; &#125; return 0;&#125; D. Euler Function题意： 求第$n$个使得$\\varphi(k)$为合数的$k$。 题解： 其实应该会有尝试，就是$n$到一定大小$\\varphi(k)$都是大于$2$的偶数，同时也是合数。其实找一下规律可以发现只有$k = 1, 2, 3, 6$时$\\varphi(k)$为质数。证明在Claris的题解里有写。 代码：123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main () &#123; int T,n; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); if (n==1) printf(\"5\\n\"); else printf(\"%d\\n\",5+n); &#125; return 0;&#125; F. Grab The Tree题意： 给定一棵$n$个点的树，每个点有权值。两个人玩游戏，先手需要占领若干不相邻的点，然后后手占领剩下所有点。每个人的得分为占领的点权异或和，分高的获胜。问最优策略下游戏的结果。 题解： 设$sum$为所有点权的异或和，$A$为先手得分，$B$为后手得分。若$sum=0$，则 $A=B$，怎样都是平局。否则考虑先手可以将原图分成两块，每一块里面的点都不相邻，然后取异或和较大的那块就好了，所以此时先手必胜。 代码：123456789101112131415#include&lt;bits/stdc++.h&gt;#define N 100010using namespace std;int main () &#123; int T,n,u,v,w; scanf(\"%d\",&amp;T); while (T--) &#123; int sum=0; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\",&amp;w),sum^=w; for(int i=1; i&lt;n; ++i) scanf(\"%d%d\",&amp;u,&amp;v); if (sum==0) printf(\"D\\n\"); else printf(\"Q\\n\"); &#125; return 0;&#125; C. Dynamic Graph Matching题意： 给定一个n个点的无向图，$m$次加边或者删边操作。在每次操作后统计有多少个匹配包含$k = 1, 2, …,\\frac n 2$条边。其中匹配是指不相交的边集。 题解： 设 f[i][S] 表示前i次操作，匹配点集为S的方案数。设当前边的两个端点为$x，y$。对于加边，显然有$f[i][S]=f[i-1][S]+f[i-1][S-x-y]。$其实，也可以直接省略第一维，执行$f[S]+=f[S-x-y]$。正确性是显然的。对于删边，由于前面加边的顺序无所谓，所以我们不妨设我们删除的正是上一次加入的边（为了方便理解）。这样，我们执行的就是一个你操作罢了：$f[S]-=f[S-x-y]$。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;using namespace std;const int mo = 1e9 + 7, N = 11;int n, m, bc[1 &lt;&lt; N], f[1 &lt;&lt; N], ans[N]; char op[5];int bitcnt (int x) &#123; return x ? bitcnt(x &gt;&gt; 1) + (x &amp; 1) : 0;&#125;int main () &#123; int T; cin &gt;&gt; T; for (int i = 0; i &lt; (1 &lt;&lt; N); ++i) bc[i] = bitcnt(i); for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m, f[0] = 1; for (int s = 1; s &lt; (1 &lt;&lt; n); ++s) f[s] = 0; for (int i = 1, x, y; i &lt;= m; ++i) &#123; scanf(\"%s%d%d\", op, &amp;x, &amp;y), --x, --y; if (op[0] == '+') &#123; for (int s = 0, t; s &lt; (1 &lt;&lt; n); ++s) &#123; if ((s &gt;&gt; x &amp; 1) || (s &gt;&gt; y &amp; 1)) continue; t = s | 1 &lt;&lt; x | 1 &lt;&lt; y; f[t] += f[s]; if (f[t] &gt;= mo) f[t] -= mo; &#125; &#125; else &#123; for (int s = (1 &lt;&lt; n) - 1, t; ~s; --s) &#123; if ((s &gt;&gt; x &amp; 1) || (s &gt;&gt; y &amp; 1)) continue; t = s | 1 &lt;&lt; x | 1 &lt;&lt; y; f[t] -= f[s]; if (f[t] &lt; 0) f[t] += mo; &#125; &#125; for (int i = 1; i &lt;= (n &gt;&gt; 1); ++i) ans[i] = 0; for (int s = 1, t; s &lt; (1 &lt;&lt; n); ++s) &#123; t = bc[s]; if (t &amp; 1) continue; else t &gt;&gt;= 1; ans[t] += f[s]; if (ans[t] &gt;= mo) ans[t] -= mo; &#125; for (int i = 1; i &lt;= (n &gt;&gt; 1); ++i) &#123; printf(\"%d%c\", ans[i], i &lt; (n &gt;&gt; 1) ? ' ' : '\\n'); &#125; &#125; &#125; return 0;&#125; G. Interstellar Travel题意： 给定平面上$n$个点，起点横坐标最小，终点横坐标最大，所有点都在第一象限内。（包括坐标轴）每次可以飞到一个横坐标严格更大的点，代价为两个坐标的叉积。求起点到终点总代价最小的飞行路线，并输出字典序最小的路线。 题解： 因为叉积的几何意义就是有向平行四边形的面积的，然后根据题目给出的性质，很快就能反应过来，只需要维护一个凸包就好了（因为这个凸包面积最大，并且是负的，对应最小代价）。注意会有重点的问题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 200005;int n, top;struct point &#123; int x, y, i; point () &#123;&#125; point (int _x,int _y,int _i = 0) : x(_x), y(_y), i(_i) &#123;&#125;&#125; a[N], s[N];point operator - (point u, point v) &#123; return point(u.x - v.x, u.y - v.y, u.i);&#125;bool cmp (point u, point v) &#123; ll t = 1ll * u.x * v.y - 1ll * u.y * v.x; return t == 0 ? (u.x == v.x ? u.i &lt; v.i: u.x &lt; v.x) : t &lt; 0;&#125;bool cmp2 (point u, point v) &#123; ll t = 1ll * u.x * v.y - 1ll * u.y * v.x; return t == 0 ? u.i &lt; v.i : t &lt; 0;&#125;void solve () &#123; s[top = 1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i].x == a[i - 1].x &amp;&amp; a[i].y == a[i - 1].y) continue; while (top &gt;= 2 &amp;&amp; cmp2(a[i] - s[top - 1], s[top] - s[top - 1])) --top; s[++top] = a[i]; &#125;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); a[i].i = i; &#125; sort(a + 2, a + n, cmp); solve(); for (int i = 1; i &lt;= top; ++i) &#123; printf(\"%d%c\", s[i].i, i &lt; top ? ' ' : '\\n'); &#125; &#125; return 0;&#125; A. Ascending Rating题意： 给定一个序列$a[1..n]$，对于每个长度为$m$的连续子区间，求出区间$a$的最大值以及从左往右扫描该区间时$a$的最大值的变化次数。 题解： 这题反正来似乎比较容易。。考虑导致维护一个单调递减的单调队列，其中队列大小$size$就是当前区间最大值的变化次数，队列中最后一个元素就是区间最大值。具体想一想就好了。其实我是不会打单调数据结构的 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 10000005;int n, m, k, p, q, r, mo, a[N];int h, t, Q[N];ll A, B;int read () &#123; int x = 0; char ch = getchar(); for ( ; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for ( ; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - 48; return x;&#125;int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p &gt;&gt; q &gt;&gt; r &gt;&gt; mo; for (int i = 1; i &lt;= k; ++i) a[i] = read(); for (int i = k + 1; i &lt;= n; ++i) a[i] = (1ll * p * a[i - 1] + 1ll * q * i + r) % mo; h = 0, t = 1, A = B = 0; for (int i = n; i &gt;= n - m + 1; --i) &#123; if (a[i] &lt; a[Q[h]]) Q[++h] = i; else &#123; for ( ; t &lt;= h &amp;&amp; a[i] &gt;= a[Q[h]]; ) --h; Q[++h] = i; &#125; &#125; A += a[Q[t]] ^ (n - m + 1); B += (h - t + 1) ^ (n - m + 1); for (int i = n - m; i; --i) &#123; if (Q[t] == i + m) ++t; if (a[i] &lt; a[Q[h]]) Q[++h] = i; else &#123; for ( ; t &lt;= h &amp;&amp; a[i] &gt;= a[Q[h]]; ) --h; Q[++h] = i; &#125; A += a[Q[t]] ^ i; B += (h - t + 1) ^ i; &#125; cout &lt;&lt; A &lt;&lt; \" \" &lt;&lt; B &lt;&lt; endl; &#125; return 0;&#125; I. Random Sequence题意： 给定一个正整数序列$a[1..n]$和一个$v$数组，每个数在$[1, m]$之间，有些数已知，有些数未知。求未知数随机填的情况下以下值的期望： \\begin{eqnarray*} \\prod_{i=1}^{n-3} v[\\gcd(a_i,a_{i+1},a_{i+2},a_{i+3})] \\end{eqnarray*} 题解： 观察下这题的数据范围，发现可以写个dp。$f[i][x][y][z]$表示将位置$1～i$（可能进行的）填数后，$a[i]=x，gcd(a[i],a[i-1])=y，gcd(a[i],a[i-1],a[i-2])=z$的期望答案（即套上连乘符号的）。则我们可以很轻松知道转移方程。但要注意的是这个连乘符号可能导致算期望的式子和我们平时做到的略有不同。总之，是有这样的式子： E[s] = V[s] * \\begin{eqnarray*} \\sum_{pre(s)}^{} E[pre]*pro[pre,s] \\end{eqnarray*}但别以为这样就完事了。注意到这样会MLE，所以你可以选择开滚动数组。然后你又被卡TLE了。注意到对于一个合法状态$(x，y，z)$，满足$z|y$且$y|x$。利用这个就可以简化状态数。然后你就稳了。注意前三项是不计贡献的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma GCC optimize(2)#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 105, mo = 1e9 + 7;int n, m, g[N][N], inv[N], a[N], v[N];int f[2][N][N][N];int ksm (int b, int p) &#123; if (p &lt; 2) return p ? b : 1; int t = ksm(b, p &gt;&gt; 1); t = 1ll * t * t % mo; return p &amp; 1 ? 1ll * t * b % mo : t;&#125;int main () &#123; int T; cin &gt;&gt; T; for (int i = 0; i &lt;= 100; ++i) g[0][i] = g[i][0] = i; for (int i = 1; i &lt;= 100; ++i) for (int j = 1; j &lt;= 100; ++j) g[i][j] = __gcd(i, j); for (int i = 1; i &lt;= 100; ++i) inv[i] = ksm(i, mo - 2); for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= m; ++i) scanf(\"%d\", &amp;v[i]); memset(f, 0, sizeof f); int nx, ny, nz, tmp; for (int z = 1; z &lt;= m; ++z) for (int y = 1; y &lt;= m; ++y) for (int x = 1; x &lt;= m; ++x) &#123; if (a[1] &amp;&amp; a[1] != z) continue; if (a[2] &amp;&amp; a[2] != y) continue; if (a[3] &amp;&amp; a[3] != x) continue; nx = x, ny = g[x][y], nz = g[ny][z]; tmp = 1; if (!a[1]) tmp = 1ll * tmp * inv[m] % mo; if (!a[2]) tmp = 1ll * tmp * inv[m] % mo; if (!a[3]) tmp = 1ll * tmp * inv[m] % mo; f[1][nx][ny][nz] += tmp; if (f[1][nx][ny][nz] &gt;= mo) f[1][nx][ny][nz] -= mo; &#125; for (int i = 3, c; i &lt;= n; ++i) &#123; c = i &amp; 1, memset(f[c ^ 1], 0, sizeof f[c ^ 1]); for (int z = 1; z &lt;= m; ++z) for (int y = z; y &lt;= m; y += z) for (int x = y; x &lt;= m; x += y) if (f[c][x][y][z]) &#123; if (a[i + 1]) &#123; nx = a[i + 1], ny = g[x][a[i + 1]], nz = g[y][a[i + 1]]; f[c ^ 1][nx][ny][nz] += 1ll * f[c][x][y][z] * v[g[a[i + 1]][z]] % mo; if (f[c ^ 1][nx][ny][nz] &gt;= mo) f[c ^ 1][nx][ny][nz] -= mo; continue; &#125; for (int j = 1; j &lt;= m; ++j) &#123; nx = j, ny = g[x][j], nz = g[y][j]; f[c ^ 1][nx][ny][nz] += 1ll * f[c][x][y][z] * v[g[j][z]] % mo * inv[m] % mo; if (f[c ^ 1][nx][ny][nz] &gt;= mo) f[c ^ 1][nx][ny][nz] -= mo; &#125; &#125; &#125; int ans = 0; for (int z = 1; z &lt;= m; ++z) for (int y = z; y &lt;= m; y += z) for (int x = y; x &lt;= m; x += y) ans = (ans + f[n &amp; 1][x][y][z]) % mo; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; M. Walking Plan题意： 给定一个$n$个点，$m$条边的有向图，$q$次询问$s$到$t$经过至少$k$条边的最短路。 题解： 注意观察数据范围。显然可以预处理出$f[k][i][j]$表示i经过恰好k条边到达j的最短路。转移方程：$f[k][i][j]=min(f[k−1][i][x]+w[x][j])$。（看f[k]长得很像个矩阵，不过这题并不用这个性质）当然你可以选择用$O(n^3 * 10000)$的时间预处理，然后愉快地gg了。当然还有更好的选择。我们来分块！我们预处理出$f[k][i][j]$表示i经过恰好k条边到达j的最短路，其中$0&lt;=k&lt;=100$。再预处理出$g[k][i][j]$表示i经过恰好100k条边到达j的最短路，其中$0&lt;=k&lt;=100$。对于一个询问，设$A = k / 100$，$B$ $=$ $k$ $mod$ $100$。则我们枚举中间点，$ans=min(a[A][s][x]+b[B][x][t])$。这样是不是就好了？错！题目中要求的是至少经过$k$条边，而非恰好。所以我们在$b$数组中做点手脚。其实就是先跑出原图的最短路，然后以“恰当的方式”更新$b$数组就好了。这个恰当的方式可以参考一下具体实现。复杂度是$O(n^3 \\sqrt k+ nq)$。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 55, K = 10005, S = 105, inf = 0x3f3f3f3f;int n, m, q, ans, g[N][N], f[N][N], A[S][N][N], B[S][N][N];int main () &#123; int T; cin &gt;&gt; T; for ( ; T; --T) &#123; cin &gt;&gt; n &gt;&gt; m; memset(g, 0x3f, sizeof g); memset(A, 0x3f, sizeof A); memset(B, 0x3f, sizeof B); for (int i = 1, x, y, z; i &lt;= m; ++i) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); g[x][y] = min(g[x][y], z); B[1][x][y] = g[x][y]; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) A[0][i][j] = B[0][i][j] = i == j ? 0 : inf; for (int k = 2; k &lt;= 100; ++k) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int x = 1; x &lt;= n; ++x) B[k][i][j] = min(B[k][i][j], B[k - 1][i][x] + B[1][x][j]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) A[1][i][j] = B[100][i][j]; &#125; for (int k = 2; k &lt;= 100; ++k) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int x = 1; x &lt;= n; ++x) A[k][i][j] = min(A[k][i][j], A[k - 1][i][x] + A[1][x][j]); &#125; for (int i = 1; i &lt;= n; i++) g[i][i] = 0; for (int x = 1; x &lt;= n; ++x) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) g[i][j] = min(g[i][j], g[i][x] + g[x][j]); &#125; &#125; for (int k = 0; k &lt;= 100; ++k) &#123; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) f[i][j] = inf; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) for (int x = 1; x &lt;= n; ++x) f[i][j] = min(f[i][j], B[k][i][x] + g[x][j]); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) B[k][i][j] = f[i][j]; &#125; cin &gt;&gt; q; for (int s, t, k, u, v; q; --q) &#123; scanf(\"%d%d%d\", &amp;s, &amp;t, &amp;k), ans = inf; u = k / 100, v = k % 100; for (int i = 1; i &lt;= n; ++i) &#123; ans = min(ans, A[u][s][i] + B[v][i][t]); &#125; if (ans &gt;= inf) ans = -1; printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125; H. Monster Hunter题意： 给定一棵$n$个点的树，除$1$外每个点有一只怪兽，打败它需要先消耗$a[i]$点 HP，再恢复$b[i]$点 HP。求从$1$号点出发按照最优策略打败所有怪兽一开始所需的最少HP（其中，过程中不能出现HP为负的情况）。 题解： 这题教会了我们从简单的情况思考。假设没有“树”的限制，即没有定死的先后顺序。怎么办？显然贪心。将怪兽分成两类考虑：$a &lt; b$和$a&gt;=b$。其实这种贪心见到过不止一次显然应该先打前一类，再打后一类。前一类的显然是先打a小的。可以感性理解一下。其实很好证，时间关系，不证了。后一类呢，稍微要想一想。我就拖一下Claris的证明吧：对于$a&gt;=b$的怪兽，考虑两只怪兽$i$,$j$。先打$i$再打$j$: $HPmin=HP - a[i] + b[i] - a[j] $先打$j$再打$i$: $HPmin=HP - a[j] + b[j] - a[i] $这样的话，我们必定会选择$b$大的先打。再回头考虑原问题。设排好序后，顺序为$p[1]，p[2]，…，p[n]$若$p[1] = 1$，那么第一步打$p[1]$一定最优。否则在打完$p[1]$的父亲$fa$后，紧接着打$p[1]$一定最优。直接合并它们。剩下的是规模为$n-1$的子问题。注意这里合并和快速搜索最优分别要用到并查集和堆。复杂度是$O(nlogn)$的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define mp make_pair#define ll long longusing namespace std;const int N = 100005;int n, P, a[N], b[N];int tot, lnk[N], nxt[N &lt;&lt; 1], son[N &lt;&lt; 1], fa[N];bool dead[N];struct mons &#123; ll a, b; int i, t; mons () &#123;&#125; mons (ll _a, ll _b, int _i = 0,int _t = 0) : a(_a), b(_b), i(_i), t(_t) &#123;&#125; bool operator &lt; (const mons &amp;o) const &#123; bool k1 = a &lt; b, k2 = o.a &lt; o.b; if (k1 != k2) return k1 &lt; k2; else return a &gt;= b ? b &lt; o.b : a &gt; o.a; &#125; void operator += (const mons &amp;o) &#123; ll na = max(a, a - b + o.a), nb = - a + b - o.a + o.b + na; a = na, b = nb; &#125;&#125; m[N], cur;priority_queue &lt;mons&gt; q;int read () &#123; int x = 0; char ch = getchar(); for ( ; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for ( ; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = x * 10 + ch - 48; return x;&#125;void add (int x, int y) &#123; nxt[++tot] = lnk[x], lnk[x] = tot, son[tot] = y;&#125;void dfs (int x, int p) &#123; fa[x] = p; for (int j = lnk[x]; j; j = nxt[j]) &#123; if (son[j] == p) continue; dfs(son[j], x); &#125;&#125;int get (int x) &#123; return dead[fa[x]] ? fa[x] = get(fa[x]) : fa[x];&#125;int main () &#123; for (int T = read(); T; --T) &#123; n = read(), tot = 0; for (int i = 1; i &lt;= n; ++i) lnk[i] = 0, dead[i] = 0; for (int i = 1; i &lt;= n * 2; ++i) nxt[i] = 0; for ( ; !q.empty(); q.pop()); m[1] = mons(0, 0, 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; m[i].a = read(), m[i].b = read(); m[i].i = i, m[i].t = 0, q.push(m[i]); &#125; for (int i = 1, x, y; i &lt; n; ++i) &#123; x = read(), y = read(); add(x, y), add(y, x); &#125; dfs(1, 0), dead[1] = 0; for (int sec = 1; !q.empty(); ++sec) &#123; cur = q.top(), q.pop(); if (cur.t != m[cur.i].t || dead[cur.i]) continue; get(cur.i), dead[cur.i] = 1; P = get(cur.i); m[P] += m[cur.i], m[P].t = sec; if (P &gt; 1) q.push(m[P]); &#125; cout &lt;&lt; max(0ll, m[1].a) &lt;&lt; endl; &#125; return 0;&#125; 剩下的题可能有点难搞了。。","path":"2018/08/01/2018hdu多校第3场补题/","date":"08-01","excerpt":""},{"title":"Test","text":"It is only A test.(我好菜啊，完全不会MarkDown。。) 我是超链接-&gt;luogu 苟利国家生死以，岂因祸福避趋之 苟利国家生死以，岂因祸福避趋之 苟利国家生死以，岂因祸福避趋之 12345678#include &lt;cstdio&gt;using namespace std;int main () &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",a+b); return 0;&#125; 据说有‘行内代码‘这种操作？！好像没有搞出来233update 有了还有数学公式什么的，以后再搞，要回去了。。现在似乎还有代码高亮和数学公式没怎么测试。","path":"2018/03/25/test/","date":"03-25","excerpt":""}]}